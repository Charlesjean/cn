
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Keep it Simple and Stupid</title>
  <meta name="author" content="Duanjin Chen">

  
  <meta name="description" content="Move语义是C++11中为了提高性能，减少临时对象的构造和析构而引入的新的语义环境，和Move语义相关的还有右值引用(rvalue reference)，这里我们总结一下，Move语义的引入带来了哪些好处，当我们定义一个类时需要注意什么。 Move语义及移动构造函数 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://Charlesjean.github.io//cn">
  <link href="/cn/favicon.png" rel="icon">
  <link href="/cn/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="" rel="alternate" title="Keep it Simple and Stupid" type="application/atom+xml">
  <script src="/cn/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/cn/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42844720-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/cn/">Keep it Simple and Stupid</a></h1>
  
    <h2>崇尚坚定的努力 更赞美自由的灵魂</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:Charlesjean.github.io//cn" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/cn/">Blog</a></li>
  <li><a href="/cn/blog/archives">Archives</a></li>
  <li><a href="/cn/blog/categories">Categories</a></li>
  <li><a href="/cn/blog/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/13/c-plus-plus-11-move-semantic/">C++11之Move 构造函数和Move 赋值操作符</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-13T11:19:04+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Move语义是C++11中为了提高性能，减少临时对象的构造和析构而引入的新的语义环境，和Move语义相关的还有右值引用(rvalue reference)，这里我们总结一下，Move语义的引入带来了哪些好处，当我们定义一个类时需要注意什么。</p>

<h4>Move语义及移动构造函数</h4>

<p>我们通过代码来看一下Move语义出现的原因及必要性。</p>

<p>假设我们有如下的类定义，TestClass类中含有一个<code>Char*</code>类型的成员变量，为了实现内存的管理，按照<code>The Big Three</code>原则，我们需要为这个类定义<code>拷贝构造函数</code>，<code>析构函数</code>和<code>赋值操作符</code>。类的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">TestClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">_array</span><span class="p">)</span> <span class="o">:</span> <span class="n">array_pointer</span><span class="p">(</span><span class="n">_array</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Constructor Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">TestClass</span><span class="p">(){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Destructor is InVoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Copy Constructor is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
</span><span class='line'>      <span class="n">memcpy</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">char</span><span class="o">*</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>拷贝构造函数</code>的语义为：当我们采用一个对象A去构造新的对象时，拷贝构造函数会被自动调用。拷贝构造函数的参数为<code>const TestClass&amp; rhs</code>决定了我们无法改变rhs的值。在下列情况下会使用拷贝构造函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">TestClass</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="n">TestClass</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于对象A的构造，拷贝构造函数完全符合我们的期望，因为我们使用了一个    <code>lvalue</code>来构造A，我们不希望改变<code>x</code>的内容，以便以后继续保持对<code>x</code>的引用。但是对于对象B的构造过程，拷贝构造函数明显做了多余的事情：</p>

<blockquote><p>  我们采用<code>rvalue</code>即一个临时变量来构造B，在B构造之后，临时变量会被销毁，我们不需要保持对这个临时变量的引用。因此，我们完全可以直接将构造函数中参数<code>rhs</code>的<code>array_pointer</code>指针直接给B，这样一来就可以省下B中<code>array_pointer</code>的初始化以及临时变量中<code>array_pointer</code>的释放过程。</p></blockquote>

<p>我们通过代码来进一步理解：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span><span class="c1">//directly assign pointer in rhs to the new object</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span><span class="c1">//do not let rhs refer to the raw pointer any more</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码就是我们所说的<code>Move Semantic</code>，当使用<code>rvalue</code>去构造或者给一个对象赋值时,我们可以直接将<code>rvalue</code>中的指针直接转移给新的对象，从而节省新的内存分配等的开销,由于<code>rvalue</code>在新的对象构造之后会被自动释放，所以我们没有必要保留对它的引用。</p>

<p>在C++11之前我们无法将上面的代码块写入构造函数中，因为我们无法区分<code>rhs</code>是不是<code>rvalue</code>。C++11中引入了右值引用，允许我们实现针对右值引用的函数重载（只在参数类型 指定右值即可），代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//This is move consturctor, transfer ownership</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//notice there are two &#39;&amp;&#39; symbols</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Move Construct is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面就是移动构造函数（Move Constructor）,函数参数为<code>TestClass&amp;&amp;</code>，表明函数接受一个<code>rvalue</code>。</p>

<p>实现移动构造函数应注意两点:</p>

<ul>
<li>参数类型为TestClass&amp;&amp;</li>
<li>需要取消rhs中指针对原地址的引用（防止在rhs析构时导致原变量被释放）</li>
</ul>


<h4>移动赋值运算符</h4>

<p>了解了移动构造函数，很自然的想到在对对象进行赋值运算时同样存在<code>rvalue</code>的问题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">A</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="n">B</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样我们可以重载移动赋值操作符如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//move assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(1)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(2)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">TestClass</span> <span class="n">tmp</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们重载了两个<code>operator=</code>操作符，当我们对<code>A</code>赋值时,(2)会被调用，当我们对<code>B</code>赋值时，(1)会被调用。</p>

<p>在c++11中你可以采用上述做法，重载两个对应复制操作符的函数，也可以使用下面更简洁的方法(unifying assignment operator)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把函数的参数改成按值传递的形式（），这样做的好处有：
*   如果我们是以一个<code>lvalue</code>对对象进行赋值，那么系统会自动构建一个对象的拷贝作为函数的参数（因为是按值传递的）
*   如果我们是以一个<code>rvalue</code>对对象进行赋值，那么这个函数的表现会像（1）一样。</p>

<p>关于赋值操作符的重载可以参考<a href="http://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap">这篇文章</a>。</p>

<p>这里有一个<a href="https://github.com/Charlesjean/C11TestProjects">demo project</a>,有兴趣的话可以下来看一下代码。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/09/objectivec-runtime-learning-3/">深入ObjectiveC Runtime之(三)NSObject类与NSObject接口</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-09T20:05:43+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在学习ObjectiveC Runtime代码是你会发现，在系统中除了一个名为NSObject的类之外，还存在一个同样名字为NSObject的接口（Protocol），这不禁让我们有疑问，NSObject接口存在的原因是什么，同样的名字难道不会有冲突吗？</p>

<p>我们先看一下接口 NSObject的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@protocol</span> <span class="nc">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">self</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nf">zone</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object1</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isProxy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isKindOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMemberOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span><span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">aProtocol</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">respondsToSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">retain</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">oneway</span> <span class="kt">void</span><span class="p">)</span><span class="nf">release</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">retainCount</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span><span class="p">;</span>
</span><span class='line'><span class="k">@optional</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">debugDescription</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们平时使用的runtime类型判断接口，以及<code>performSelector</code>等都定义在以NSObject为名的Protocol当中。这些方法在我们平时的编程过程中被大量使用，基本上所有的类都可以respond to这些方法，而我们的类都是继承自NSObject的，他们为什么会有NSObject Protocol当中声明的方法呢，唯一的解释就是<code>Class NSObject 实现了 NSObject Protocol</code>，在runtime的代码中我们也可以得到印证</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span>  <span class="n">OBJC_ISA_AVAILABILITY</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上在ObjectiveC中，interface和protocol的名字是可以相同的，因为在语言中不存在任何可以产生歧义的语法，也就是说interface和protocol使用于完全不同的语法环境，因此可以有相同的名字。</p>

<p>我们还可以进一步思考NSObject Protocol存在的必要性。在JAVA中，所有的类都是java.lang.Object的子类（Object是唯一的ROOT Class），而ObjectiveC中并不是所有的类都是NSObject的子类（有些类继承自NSProxy而不是NSObject）。因此在ObjectiveC中，为了给所有的类提供某些通用的接口，就必须保证所有的ROOT Class，都去实现某一个Protocol，NSObject Protocol就因此诞生，即<code>所有的root class，包括NSObject和NSProxy都会实现NSObject Protocol</code>， 我想这才是NSObject Protocol存在的根本原因。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/03/objectivec-runtime-learning-2/">深入ObjectiveC Runtime之（二）安装Clang</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-03T21:20:48+08:00" pubdate data-updated="true">Apr 3<span>rd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在<a href="http://dj-chen.com/cn/blog/2014/03/26/objectivec-runtime-learning-1/">上一篇</a>中我们通过阅读代码，了解了ObjectiveC的内部对象模型的实现，接下来我们继续通过代码来了解ObjectiveC是如何加载一个类，以及ObjectiveC是如何实现对Category的支持的。</p>

<p>我们需要利用Clang来生成一部分中间代码，帮助我们了解runtime的运行机制，因此我们首先需要安装Clang。</p>

<p>Clang是LLVM的前端，可以用来编译C，C++，ObjectiveC等语言。传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。Clang则是以LLVM为后端的一款高效易用，并且与IDE结合很好的编译前端。</p>

<p>我们需要自己下载LLVM与Clang源代码进行编译，步骤如下：</p>

<figure class='code'><figcaption><span>lang=shell </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm 
</span><span class='line'>
</span><span class='line'>cd llvm/tools 
</span><span class='line'>svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
</span><span class='line'>cd ../..
</span><span class='line'>
</span><span class='line'>cd llvm/projects
</span><span class='line'>svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt
</span><span class='line'>cd ../..
</span><span class='line'>
</span><span class='line'>mkdir build 
</span><span class='line'>cd build
</span><span class='line'>../llvm/configure
</span><span class='line'>make</span></code></pre></td></tr></table></div></figure>


<p>至此，Clang 安装完毕，你可以使用<code>clang --help</code>来验证是否正确安装。</p>

<p>工欲善其事必先利其器，安装Clang主要是为我们今后的学习做准备，我本身对编译器没有特别深入的学习，如果你对Clang感兴趣可以<a href="http://clang.llvm.org/">参考这里</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/03/30/android-statelistdrawable-and-colorstatelist/">Android通过代码设置控件点击时颜色变化</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-30T12:54:00+08:00" pubdate data-updated="true">Mar 30<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在UI设计时，我们通常希望用户得到及时的交互反馈，例如在按钮上发生点击事件，或者textView上发生点击时，我们通常采用highlight一个控件的方法，提醒用户点击事件的发生。我们通常会通过改变控件的背景颜色或者字体的颜色来达到高亮的效果，Android提供了两个类，StateListDrawable和ColorStateList来支持这种操作。</p>

<p>在Android的<a href="http://developer.android.com/guide/topics/resources/color-list-resource.html">官方文档</a>以及网上很多资料中，我们可以看到这种高亮的支持都会通过编写xml来实现的。个人认为xml的实现方式虽然简单、可复用，但是如果我们有很多种状态，或者要动态的产生不同的颜色效果，那么XML的方式会使我们的工程中增加很多的resource文件，作为一个Programmer我更喜欢通过代码来达到相同的目的。本文所用的例子比较简单，仅仅是对一个textview做了高亮设置，当用户点击textiew时，会改变其背景色和字体颜色，可以在<a href="https://github.com/Charlesjean/FragmentTest">这里</a>下载代码。关键代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    *Add statedrawable for targetView to display different drawable when</span>
</span><span class='line'><span class="cm">    * view is in different state</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addStateDrawable</span><span class="o">(</span><span class="n">View</span> <span class="n">targetView</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">StateListDrawable</span> <span class="n">listDrawable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateListDrawable</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//add drawable used when view is pressed</span>
</span><span class='line'>        <span class="n">listDrawable</span><span class="o">.</span><span class="na">addState</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">android</span><span class="o">.</span><span class="na">R</span><span class="o">.</span><span class="na">attr</span><span class="o">.</span><span class="na">state_pressed</span><span class="o">},</span> <span class="k">new</span> <span class="n">ColorDrawable</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">rgb</span><span class="o">(</span><span class="mi">106</span><span class="o">,</span><span class="mi">170</span><span class="o">,</span><span class="mi">234</span><span class="o">)));</span>
</span><span class='line'>        <span class="c1">//show gray background for all other state</span>
</span><span class='line'>        <span class="n">listDrawable</span><span class="o">.</span><span class="na">addState</span><span class="o">(</span><span class="n">StateSet</span><span class="o">.</span><span class="na">WILD_CARD</span><span class="o">,</span> <span class="k">new</span> <span class="n">ColorDrawable</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">GRAY</span><span class="o">));</span>
</span><span class='line'>        <span class="n">targetView</span><span class="o">.</span><span class="na">setBackgroundDrawable</span><span class="o">(</span><span class="n">listDrawable</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * set different text color for different state</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addColorState</span><span class="o">(</span><span class="n">TextView</span> <span class="n">targetView</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">states</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">android</span><span class="o">.</span><span class="na">R</span><span class="o">.</span><span class="na">attr</span><span class="o">.</span><span class="na">state_pressed</span><span class="o">},</span>
</span><span class='line'>                <span class="n">StateSet</span><span class="o">.</span><span class="na">WILD_CARD</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">colors</span> <span class="o">=</span> <span class="o">{</span><span class="n">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">,</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">};</span>
</span><span class='line'>        <span class="n">ColorStateList</span> <span class="n">coloList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ColorStateList</span><span class="o">(</span><span class="n">states</span><span class="o">,</span> <span class="n">colors</span><span class="o">);</span>
</span><span class='line'>        <span class="n">targetView</span><span class="o">.</span><span class="na">setTextColor</span><span class="o">(</span><span class="n">coloList</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>StateListDrawable 提供了<code>addState</code>接口，使我们能够对应每一种状态，设置一个drawable；ColorStateList同样使我们为每一种状态指定一种字体颜色。 其中<code>StateSet.WILD_CARD</code>表示去除当前已有状态外的其他所有状态。</p>

<p>所谓状态就是指随着用户的交互，View所出的不同的状态。 其中<code>state_pressed</code>表示<code>when the user is pressing down in a view.</code>,更多对状态的描述可以参考<a href="http://developer.android.com/reference/android/graphics/drawable/StateListDrawable.html">android 文档</a> (个人认为android的很多文档写得很烂，完全是对字面意思的解释，这一点与iOS根本无法相比)。</p>

<h3>使用StateListDrawable和ColorStateList需要注意的事项</h3>

<ul>
<li>首先由于控件的状态是随着用户的点击等事件而改变的，所以要想使之前的代码能起作用，我们必须确保view能够接受用户的点击事件，最基本的必须用<code>setClickable(true)</code>,使控件可以点击</li>
<li>由于android对点击等事件的传递有一定的规则，要使<code>StateListDrawable</code>和<code>ColorStateList</code>起作用，最根本上要保证view的<strong>onTouchEvent</strong>函数能够被调用到，即TouchEvent不能被其他的对象 如<code>ParentView</code>和<code>TouchListener</code>所截断。(如果view注册了EventListener那么事件就会在传给onTouchEvent()函数之前，被EventListener截断)。</li>
</ul>


<p>关于Android中事件的传递机制，可以参考<a href="">这篇文章</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/03/26/objectivec-runtime-learning-1/">深入ObjectiveC Runtime之对象模型</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-26T07:36:12+08:00" pubdate data-updated="true">Mar 26<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ObjectiveC与C++同样是在C的基础上对C的扩展，但与C++相比，我认为ObjectiveC提供了更加强大的功能，比如Category，forward message, method-swiazzing, KVO以及一些runtime接口，而所有这些技术都是以ObjectiveC强大的Runtime为基础的。因此只有深入学习了runtime的机制，才能使我们对OC的使用更加得心应手， 并且对于大多数runtime技术，我们必须在熟悉它的底层实现机制后才能够达到正确使用的目的，否则的话你将陷入痛苦的debug之中。</p>

<p>对象模型是程序运行时对象在内存中的组织方式，由于ObjectiveC是OOP的编程语言，对象模型就涉及到<code>类的组织方式</code>,<code>继承关系的表示方法</code>，<code>成员变量与函数的存储方式</code>，<code>如何实现RTTI</code>等，因此对象模型是我们了解ObjectiveC runtime技术实现机制的基础。</p>

<h3>ObjectiveC中对象的数据结构</h3>

<p>我们都知道，ObjectiveC中的大多数类都是NSObject的子类，因此我们先从NSObject的结构开始,在NSObject.h中我们可以看到如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NS_ROOT_CLASS</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span>  <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>NSObject类中只有一个名为<code>isa</code>的<code>Class</code>类型的变量，跳转到<code>Class</code>的定义我们可以看到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_class</span> <span class="o">*</span><span class="n">Class</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Class</code>为指向<code>objc_class</code>的指针，而<code>objc_class</code>就代表了在Objectivec中一个类的定义。其源代码定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_class</span> <span class="o">:</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Class ISA;</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">superclass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cache_t</span> <span class="n">cache</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们看到<code>objc_class</code>继承自<code>objc_object</code>,而<code>objc_object</code>的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="n">uintptr_t</span> <span class="n">isa</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc_object只保存了一个<code>isa</code>指针，在原代码中我们还可以看到</p>

<pre><code>typedef struct objc_object *id;
</code></pre>

<p>看到这里一切应该都已经明了了。我们知道在ObjectiveC中每一个对象都是一个<code>id</code>,所以<code>objc_object</code>就是我们每一个对象在内存中的结构，它保存了一个指向<code>objc_class</code>的指针，这个指针就指向对象所对应的类在内存中的位置。</p>

<p>既然<code>objc_class</code>代表了ObjectiveC中的类，那么结构中必然需要存储类的相关信息，包括类的名字，成员函数的位置等信息，在ObjectiveC2.0中，这些信息被封装在了<code>class_rw_t</code>和<code>class_ro_t</code>当中，他们代码定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">class_rw_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">version</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">class_ro_t</span> <span class="o">*</span><span class="n">ro</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">**</span><span class="n">method_lists</span><span class="p">;</span>  <span class="c1">// RW_METHOD_ARRAY == 1</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">method_list</span><span class="p">;</span>    <span class="c1">// RW_METHOD_ARRAY == 0</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">chained_property_list</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">protocol_list_t</span> <span class="o">**</span> <span class="n">protocols</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Class</span> <span class="n">firstSubclass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">nextSiblingClass</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">class_ro_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">instanceStart</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">instanceSize</span><span class="p">;</span>
</span><span class='line'><span class="cp">#ifdef __LP64__</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">uint8_t</span> <span class="o">*</span> <span class="n">ivarLayout</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">method_list_t</span> <span class="o">*</span> <span class="n">baseMethods</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">protocol_list_t</span> <span class="o">*</span> <span class="n">baseProtocols</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">ivar_list_t</span> <span class="o">*</span> <span class="n">ivars</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">uint8_t</span> <span class="o">*</span> <span class="n">weakIvarLayout</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">property_list_t</span> <span class="o">*</span><span class="n">baseProperties</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此我们基本上了解了ObjectiveC中对象的组织形式，总结如下：</p>

<blockquote><p>每一个ObjectiveC对象都保存了一个<code>isa</code>指针指向其所对应的类的实现<code>objc_class</code>，而<code>objc_class</code>中保存了类父类，名称，函数列表，以及Protocol等信息。</p></blockquote>

<p>但是有些内容还不是特别清晰：</p>

<blockquote><ul>
<li>对象的成员变量应该是局部于对象的，不应该保存在<code>objc_class</code>中，对于成员变量这部分的实现还不清晰</li>
<li>对于大部分文章中提到的<code>元类</code>在代码中是如何体现的？ 目前我在代码中没有看到</li>
</ul>
</blockquote>

<p>以上ObjectiveC基本的对象模型，在这个对象模型的基础上ObjectiveC提供给了我们丰富的Runtime特性以及OO的支持，以后我们会进一步深入了解一些重要特性的实现。</p>

<p>我阅读的代码版本是Objc4-551，是官方开源的最新代码，如果文章中有错误或者有更详尽的看法请留言，共同学习进步。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/03/25/personal-blog-with-github-and-octopress/">基于Github托管的Octopress个人博客</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-25T07:33:30+08:00" pubdate data-updated="true">Mar 25<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>   Github Pages 一直是自己喜爱的博客形式，之前托管了一个简单的英文博客，直接将博客的源代码放在username.github.io项目下，
代码管理简单，但是需要github在访问时将Jeklly转换为静态的网页，未免会带来网站性能的损失。Octopress 提供了更好的管理博客的方法，并集成了更多可以使用的插件和自动化的功能，这个中文博客就是基于Octopress，仍然托管在Github上，不过不是以个人网页的形式，而是以project pages的形式托管.</p>

<p>  在部署octopress的时候，会遇到不少问题，这里主要来记录一下，以备以后使用.</p>

<h4>fatal：remote origin already exists</h4>

<p>我的配置环境为reby 1.9.3， 在根据Octopress的<a href="http://octopress.org/docs/setup/">官方文档</a>安装主题之后，并在github上建立好新的repository之后，执行rake setup_github_pages会出错，提示</p>

<pre><code>remote origin already exists
</code></pre>

<p>解决方法：将Octopress/Rakefile中357行</p>

<pre><code>git remote add origin #{repo_url} 改为 git remote set-url origin #{repo_url}
</code></pre>

<h4>修改相应的配置文件</h4>

<p>由于现在的中文博客是放在github的一个project上，目的是为了实现如下方式访问：username.github.io/project,所以我们需要修改一下Octopress的配置文件，来指明目录结构。</p>

<ul>
<li>_config.yml:修改url,root,destination</li>
<li>config.rb:修改http_path,http_image_path,http_fonts_path,css_dir</li>
</ul>


<p>具体的改变可以参考<a href="https://github.com/Charlesjean/cn">这里</a>相对应的文件。</p>

<h4>UTF-8或者GB2312编码问题</h4>

<p>在执行rake generate命令之后，如果遇到 invalid byte sequence UTF-8 等错误，说明在你的文件当中有非法的编码字符，这些字符可能是由于我们使用的编辑器默认添加的一些字符，这里我们首先推荐使用nodepad++或者markdown专用的编辑器。</p>

<p>解决方法：</p>

<ul>
<li>修改Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-0.12.1\lib\jekyll\convertible.rb， 改变如下</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.content = File.read(File.join(base, name),:encoding=>"utf-8")</span></code></pre></td></tr></table></div></figure>


<ul>
<li>利用nodepad++找出非法字符，并将文档编码设置为utf-8 without BOM</li>
</ul>


<p>上面基本上列出了我在搭建过程中遇到的问题，喜欢用github搭建博客的都起码有一些编程能力，相信大家应该都可以很好地解决这些基本的问题，也欢迎大家反映自己遇到的问题，我们一起讨论解决。</p>

<p>再一次感谢Github提供了如此简单，可靠，关键还是免费的搭建博客的支持:)</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/cn/blog/archives">文章列表</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
 <h1>Archives</h1>
 <ul id="categories">
  <li class='category'><a href='/cn/blog/categories/android/'>Android(1)</a></li>
<li class='category'><a href='/cn/blog/categories/c-/'>C++(1)</a></li>
<li class='category'><a href='/cn/blog/categories/objectivec/'>ObjectiveC(3)</a></li>
<li class='category'><a href='/cn/blog/categories/octopress/'>Octopress(1)</a></li>

  </ul>
  </section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/cn/blog/2014/04/13/c-plus-plus-11-move-semantic/">C++11之Move 构造函数和Move 赋值操作符</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/04/09/objectivec-runtime-learning-3/">深入ObjectiveC Runtime之(三)NSObject类与NSObject接口</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/04/03/objectivec-runtime-learning-2/">深入ObjectiveC Runtime之（二）安装Clang</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/03/30/android-statelistdrawable-and-colorstatelist/">Android通过代码设置控件点击时颜色变化</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/03/26/objectivec-runtime-learning-1/">深入ObjectiveC Runtime之对象模型</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Visitors</h1>
  <script type="text/javascript" src="http://ji.revolvermaps.com/2/1.js?i=89aid7d1ejy&amp;s=220&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Duanjin Chen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
