
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Keep it Simple and Stupid</title>
  <meta name="author" content="Duanjin Chen">

  
  <meta name="description" content="长久以来Android给人们的印象都是反应速度慢，不够流畅，这也是我之前对android的印象，在接触了Android4.4、从事了android的开发后，我觉得Android之所以给人们不够流畅的原因有以下几点： 与iOS不同的是，Android手机型号众多，配置更是各种各样， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://Charlesjean.github.io//cn">
  <link href="/cn/favicon.png" rel="icon">
  <link href="/cn/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="" rel="alternate" title="Keep it Simple and Stupid" type="application/atom+xml">
  <script src="/cn/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/cn/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42844720-3']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/cn/">Keep it Simple and Stupid</a></h1>
  
    <h2>崇尚坚定的努力 更赞美自由的灵魂</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:Charlesjean.github.io//cn" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/cn/">Blog</a></li>
  <li><a href="/cn/blog/archives">Archives</a></li>
  <li><a href="/cn/blog/categories">Categories</a></li>
  <li><a href="/cn/blog/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/05/26/android-art-vs-dalvik/">Android ART 与 Dalvik虚拟机比较</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-26T21:39:15+08:00" pubdate data-updated="true">May 26<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>长久以来Android给人们的印象都是反应速度慢，不够流畅，这也是我之前对android的印象，在接触了Android4.4、从事了android的开发后，我觉得Android之所以给人们不够流畅的原因有以下几点：</p>

<ul>
<li>与iOS不同的是，Android手机型号众多，配置更是各种各样，以我之前用的HTC手机为例，2012年出厂的手机装配了Android4.0的系统，但是系统的内存却只有512M，开机后app的可用内存只有可怜的360M，这种配置的手机怎么可能有好的表现，不卡才怪。而iOS的手机型号固定，配置起码都是1G的内存，运行流畅是必然的。</li>
<li>Android市场对app的审核不如iOS严格，致使Android App的质量良莠不齐，很多开发者并没有对app进行足够的性能优化，成功如微博客户端，在滑动的时候仍不够流畅，其他的app质量可想而知。</li>
<li>最根本的一点是，Dalvik虚拟机在作怪。</li>
</ul>


<p>大家都知道，Java为了达到跨平台的目的，在编译时将源代码转化为了字节码，Android的Dalvik虚拟机亦是如此，在我们运行app时，系统必须将字节码转换为机器码，然后运行，这种机制就是Dalvik使用的JIT（Just-in-time compilation）机制。在运行时才将字节码转化为机器码，这可以说是android app不够流畅的根本原因，因为我们无法消除将字节码转化为机器码的这部分时间。</p>

<p>Android4.4引入了ART，即Android Runtime，与Dalvik不同的是，ART在我们第一次安装app时，会自动将app转化为机器码，从而确保了app运行时的时间（去除了JIT compile的时间），因此开启ART后，android app流畅度会有一个不错的提升。但是目前，ART有如下问题：</p>

<ul>
<li>某些app在ART下无法运行。这应该是针对一小部分app，因为我目前为止在我的手机上没有发现这个问题</li>
<li>由于在首次安装时需要将app转化为机器码，因此app的安装时间会有所增加。我在使用过程中也没有明显的感觉到这一点，可以说这点不会妨碍一般的用户。</li>
</ul>


<p>可以说ART很好的解决了android不够流畅的问题，并且对于普通用户，并没有带来使用的负面影响，况且现在ART还在进一步的改进和开发当中，相信以后在流畅度，安装时间等各个方面会做的更好。 对于我们开发者，ART也带来了实际的好处。</p>

<p>相信很多开发者会遇到一个问题，就是在Android中，如果你的ViewGroup嵌套层次太多，那么很可能会遇到StackOverflowError这个运行时错误，产生这个错误的原因是由于View Hierarchy在绘制过程中，函数调用的深度超出了系统主线程的Stack frame。在Android4.4中，Dalvik的UI线程的Stack frame只有16K，过多的嵌套很容易造成StackOverflowError，而对于程序，很难从根本上解决这个问题（优化view hierarchy被认为是唯一可行的方法，但实用性却是有限的）。我在试验中发现，ART已经很好的解决了这个问题，即使view group的嵌套达到了60层，仍然不会出现在Dalvik中的crash。</p>

<p>由此可见，ART正在试图解决一些Dalvik中存在的性能等各个方面的问题，或许Android5.0的时候，ART能够成型，那Android必然会向前迈一大步，用户体验可以得到很大的改观（当然像之前说的HTC的那种奇葩配置的机器，永远不可能有好的流畅度）。</p>

<p>由于Android生态的多样性，各个生产商的Android都有很大的不同，我们应该通过比较来区分优劣，Android有自己的特点，包括Android App的设计原则都不同于iOS，作为Android用户，我们需要的不是iOS，而是Android自己的个性，Android的特色。越来越对Android充满信心，相信Android很快可以做的更好。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/05/22/nexus5-windows-debug/">解决Windows下Android Device Manager无法找到Nexus5</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-22T21:50:49+08:00" pubdate data-updated="true">May 22<span>nd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一直用公司的MAC开发Android，在将Nexus5连接到自己的Windows上时，发现ADT中无法找到Nexus5，adb devices命令也无法检测到设备，虽然设备能够以磁盘的方式显示在Windows Explorer中，但是似乎设备的驱动仍然没有正确的安装：</p>

<ul>
<li>打开windows 设备管理器可以发现，Nexus5设备标识上有一黄色叹号，表示驱动没有正确安装</li>
<li>下载Nexus5 <a href="http://developer.android.com/sdk/win-usb.html#top">设备驱动</a>，并解压至某一目录</li>
<li>在设备管理器中，右键点击设备，并更新驱动</li>
<li>选中刚才解压的目录，即可正确的安装驱动</li>
</ul>


<p>Issue Fixed ：）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/05/20/goagent-android-sdk-download/">解决Android SDK Manager无法下载SDK的问题</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-20T22:31:33+08:00" pubdate data-updated="true">May 20<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>计算机应用可以说是少数国内与国外技术差别比较小的领域，主要原因是网络的帮助，使我们很方便的看到国外的技术文档与很多优秀的文章，但是很多时候国内的环境确实令人非常气愤，居然Android SDK网站都会被墙，以至于Android SDK Manager根本无法下载。解决方法是安装并打开goagent，并将SDK Manager的Proxy设置为<code>127.0.0.1:8087</code>。如果不知道goagent的话，那就好好搜索一下吧，国内的环境，基本上这个是必备的了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/05/17/c-plus-plus-11-new-feature/">C++11 常用新语言特性总结</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-17T14:07:31+08:00" pubdate data-updated="true">May 17<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>C++11给我们提供了很多新的特性，相比于C++98，C++11在很多地方使用起来更加顺手，很多新的特性让C++变得更加让人喜欢，对编码人员更加友好，很多规则更加统一。在这些新的特性当中，有很多高级特性，比如关于模板的特性（个人真的很少在开发中用到）；也有很多确确实实方便了开发，而且使c++代码更加整洁、安全、快速的特性。在学习中总结一下，往往可以在使用过程中更加得心应手。</p>

<h4>auto</h4>

<p>c++11中auto关键字和c++98中有完全的不同，在c++11中，如果我们把变量声明为auto，那么编译器会自动根据上下文推断出变量的类型，因此在很多情况下，特别是类型比较长的时候，我们可以使用auto来使代码更加整洁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="p">.....</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="c1">//get iterator of vector,do not need to use vector&lt;String&gt;::iterator</span>
</span></code></pre></td></tr></table></div></figure>


<p>乍一看，这仅仅是提供了一些编程上的方便，但是实际上在很多类型不确定的时候，auto提供了更大的帮助</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">multiply</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vt</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">vu</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">vt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">vu</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//here it&#39;s hard to decide type of tmp, auto saves us a lot</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>智能指针</h4>

<p>在c++11中，智能指针使用起来更加顺手，相比于之前的auto_ptr, unique_ptr和shared_ptr更加容易的和stl容器一起使用。unique_ptr顾名思义为独有指针，被unique_ptr包含的指针在任意时刻只能有一个unique_ptr拥有，任何对unique_ptr的赋值和拷贝都会产生指针的移动；shared_ptr是实现了引用计数的智能指针，相对于unique_ptr，shared_ptr需要维护一个计数对象，因此在赋值和拷贝时，较unique_ptr会产生更大的开销。weak_ptr是用来避免循环引用。（在另一篇文章中，我们会比较这几种智能指针的使用）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">gadget</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">gadget</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">;</span> <span class="c1">// if shared ownership</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">gadget</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">;</span><span class="c1">//avoid cycle reference</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h4>nullptr</h4>

<p>在C++11中我们可以使用nullptr来指定一个指针为空，而不再使用0 或者NULL。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="kt">char</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//do not use this any more, if you use, p==p2 is still ok</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//for function</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//will call f(int)</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span><span class="c1">//will call f(char*)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Range for</h4>

<p>c++11中也引入了更加有好的for循环语法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//c++98 </span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//c++11</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">audo</span> <span class="n">d</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Range-for语法不仅适用于stl容器，还可以用于string, array。</p>

<h4>不需使用容器的begin和end成员函数</h4>

<p>begin()和end()方法不仅仅可以用于stl 容器，还可以用于数组当中，看如下的对比代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'><span class="c1">//c++98</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//c++11</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>对比如此明显，你还会用原来的语法吗？</p>

<h4>Move Semantic</h4>

<p>可以参考<a href="http://dj-chen.com/cn/blog/2014/04/13/c-plus-plus-11-move-semantic/">这篇文章</a></p>

<h4>类成员变量的初始化</h4>

<p>在c++11中允许我们在声明成员变量时给出初始化，避免了需要在所有的构造函数中提供变量的初始化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>      <span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>      <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a_val</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a_val</span><span class="p">)</span> <span class="p">{}</span><span class="c1">//a_aval will replace 7</span>
</span><span class='line'>      <span class="n">A</span><span class="p">(</span><span class="n">D</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">b</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{}</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span><span class="c1">//this is ok</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="c1">//this is ok</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>      <span class="n">HashingFunction</span> <span class="n">hash_algorithm</span><span class="p">{</span><span class="s">&quot;MD5&quot;</span><span class="p">};</span>  <span class="c1">// Cryptographic hash to be applied to all A instances</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="s">&quot;Constructor run&quot;</span><span class="p">};</span>       <span class="c1">// String indicating state in object lifecycle</span>
</span><span class='line'>    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h4>托管构造</h4>

<p>C++11允许我们托管构造，即在一个构造函数中调用另一个构造函数，实现类状态的初始化，避免了我们之前经常需要自己实现一个Init函数，然后在各个构造函数中调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>      <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">max</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="n">x</span><span class="p">;</span> <span class="k">else</span> <span class="k">throw</span> <span class="n">bad_X</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>      <span class="n">X</span><span class="p">()</span> <span class="o">:</span><span class="n">X</span><span class="p">{</span><span class="mi">42</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>      <span class="n">X</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span><span class="n">X</span><span class="p">{</span><span class="n">lexical_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">)}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11还有许多其他的新的特性或者语法，这里只是自己平时用到的，觉得比较实用的，欢迎大家提出自己喜欢的新特性。对于C++11中的lambda语法，我个人不是太喜欢，因为不是特别容易调试:)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/05/02/core-animation/">iOS中Core Animation的使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-02T21:26:21+08:00" pubdate data-updated="true">May 2<span>nd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>用户体验是用户在使用一款软件和系统时，对软件和系统能得到的最直观的感受，iOS一直因为良好的用户体验而受到大家的赞赏，流畅的操作和丰富的动画无疑给iOS的用户体验加了不少分。对于我们编程人员来说，iOS中提供了强大的Core Animation库，并封装了友好的API，使我们能够实现复杂的动画效果。</p>

<p>Core Animation提供了两种动画的类型，并封装成类CABasicAnimation和CAKeyframeAnimation，我们需要针对自己的目标来选择使用这两种类。动画的实现过程实际上就是在一定时间内连续播放一系列的视频帧，在iOS中要求60帧/秒，通常情况下，我们实现动画的做法是给出动画在一定时间内的<code>关键帧</code>，然后利用<code>差值</code>的方法得到关键帧之间的所有帧序列的状态。CABasicAnimation 和 CAKeyframeAnimation的最大区别就是</p>

<blockquote><pre><code>  CABasicAnimation要求我们只能提供动画的第一帧和最后一帧，然后系统利用我们指定的插值方法，计算出整个动画的所有序列；
    而利用CAKeyframeAnimation我们可以给出动画过程中的多个关键帧，然后同样系统利用我们制定的插值方法，计算出连续的两个关键帧之间的所有序列，从而实现动画。 
    可以看到，利用CAKeyframeAnimation，我们对动画有更多的控制权，因此大多数比较复杂的动画也需要选用CAKeyframeAnimation。
</code></pre></blockquote>

<p>我在<a href="https://github.com/Charlesjean/CoreAnimationDemo">demo</a>中实现了两种动画效果，动画并不算复杂，但是却能很好的了解这两种动画类的使用，并且由于动画是作用在CALayer之上，因此CALayer的相关知识也是我们能够正确的使用Core Animation的基础，在例子中你也可以看到一些CALayer的属性，如anchor point，transform等是如何使用的。demo的效果如下：
<video width='' height='' preload='none' controls poster=''><source src='https://raw.githubusercontent.com/Charlesjean/CoreAnimationDemo/master/demo.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'></video></p>

<p>当我们在屏幕上滑动时，view controller会移除当前view（currentView），并添加新的view（nextView），并通过动画来达到比较优美的效果。Demo中含有两种动画效果，当我们像左滑动时，触发了folder animation，当我们向右滑时触发了accordion animation。</p>

<h4>Render tree 和 Presentation tree</h4>

<p>CALayer与UIView类似，对于一个有UIView组成的View Hierarchy，同样也有一个对应的Layer Hierarchy。但是Layer Hierarchy又对应两种不同的树结构，我们称作Render tree 和 Presentation tree，理解了render tree和presentation tree后，有利于我们解决动画过程当中的某些问题（在动画开始和结束时候的可能出现的闪烁问题）。</p>

<p>我们以一个例子来解释这两个概念。
在CALayer中很多属性是可以触发动画的，我们看如下简单代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在layer的背景色被改变后，我们可以看到动画中layer的颜色会由原来的颜色，慢慢过渡为红色。在动画中我们看到的layer的状态（颜色随时间而变化）就是presentation tree中layer的状态，而当动画结束后，layer最终呈现的状态就是render tree中的状态。换句话说，动画中我们改变的是presentation tree中layer的状态，而不是layer最终呈现的状态，如果我们将改变颜色的一个CABasicAnimation对象作用到layer上，动画会呈现出来（presentation tree）而layer在动画结束的瞬间仍然会变回原来的颜色（render tree）。</p>

<h4>Folder Animation</h4>

<p>Folder动画给我们的感觉是类似翻书的效果，要实现这个动画我们首先需要考虑如何将动画分解，及动画中我们将涉及到CALayer的布局如何，我们实现动画所需要改变的属性是什么。按照folder动画的效果，我们可以将这个动画分解为下图所示：</p>

<p><img src="https://raw.githubusercontent.com/Charlesjean/cn/master/source/_posts/folder.png" alt="" /></p>

<p>直观上我们可以看到图中包含了三个CALayer，黄色的leftLayer，绿色的rightLayer，已经处于旋转状态的rotateLayer。动画的整个过程就是rotateLayer绕Y轴旋转180度的过程。</p>

<p>folder动画应该满足的要求为：
*   rotateLayer在旋转的时候应该有透视（Perspective）的效果
*   rotateLayer似乎有两个面，正面显示的内容为currentView的右半部分，反面显示的为nextView的左半部分</p>

<p>查看代码，在FolderAnimation.mm中，我们可以看到以下的变量声明</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">FolderAnimation</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CATransformLayer</span><span class="o">*</span> <span class="n">animationLayer</span><span class="p">;</span><span class="c1">//rotateLayer</span>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">frontAnimationLayer</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">backAnimationLayer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">currentViewHalfLayer</span><span class="p">;</span><span class="c1">//leftLayer</span>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">nextViewHalfLayer</span><span class="p">;</span><span class="c1">//rightLayer</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们实际需要使用5个Layer来完成这个动画，其中需要旋转并带有透视效果的layer我们选择的是CATransformLayer，在CATransformLayer上，我们需要放置两个CALayer，作为它的&#8221;正面&#8221;和&#8221;反面&#8221;。</p>

<p>CALayer的绘制是二维的，也就是说在将CALayer的整个Layer Hierarchy绘制到屏幕上之前，CALayer当中所有的layer都会被先绘制到一张bitmap上面，然后系统再将这张bitmap显示出来。这种绘制方式决定了，我们的要求2无法满足，也就是说一个layer不可能有两个不同的面，这种情况下我们就需要使用CATransformLayer。CATransformLayer允许我们建立三维的Layer Hierarchy，也就是说它的所有的Sub Layer存在于一个三维的空间内，我们可以对他们进行旋转、平移等操作，也正是由于CATransformLayer模拟了三维的空间，所以它可以提供给我们透视（perspective）的效果（具体可以参见CATransformLayer的文档）。</p>

<p>建立好了用于动画的Layer Hierarchy之后，下一步就是要向rotateLayer添加动画，因为本例中只涉及了一个转动的动画，所以我们选择使用CABasicAnimation</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="n">CABasicAnimation</span><span class="o">*</span> <span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;transform&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CATransform3D</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DIdentity</span><span class="p">;</span>
</span><span class='line'>    <span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DRotate</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span>  <span class="n">direction</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">transform</span><span class="p">.</span><span class="n">m34</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">*</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">1000</span><span class="p">;</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCATransform3D:</span><span class="n">transform</span><span class="p">];</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">duration</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">animationLayer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="n">Nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>动画的代码比较简单，我们将图中的rotateLayer旋转了180度，需要注意的有两点：</p>

<ul>
<li>1.transform.m34的设置是为了产生透视效果，至于transform的意义涉及到图形学中的视图投影矩阵的内容，会在另一篇文章中阐述</li>
<li>2.animation.delegate的设置是为了监听动画的结束，以便做一些动画结束时的工作（保证presentation tree的最后状态与render tree一致）。</li>
</ul>


<h4>Accordion Animation</h4>

<p>相对于folder animation来说accordion animation的实现要复杂许多。
下图示意了Accordion的过程：</p>

<p><img src="https://raw.githubusercontent.com/Charlesjean/cn/master/source/_posts/accordition.png" alt="" /></p>

<p>其中A、B、C为“表面上”看起来需要做动画的Layer，在C向右<code>移动</code>的过程中，A和B需要一边向右<code>移动</code>一边绕轴<code>转动</code>,再仔细想一下，还有以下要求：</p>

<ul>
<li> 1.A和B在转动的过程中需要有透视的效果,即A和B的父Layer需要是一个CATransformLayer</li>
<li> 2.移动与转动过程中A 与 C需要一直保持邻接，即A的边在X方向的移动速度要与C的移动速度相同</li>
<li> 3.在移动和转动过程中A 与 B需要一直保持邻接，A与B在X方向上具有相同的移动速度</li>
<li> 4.B的最右边，即红色的线，需要保持不变，B的红边须保持“不动”</li>
</ul>


<p>相对于folder动画，accordion不再是只在某一个layer上实现动画，而是多个layer结合起来实现动画，而且过程中多了许多限制条件。
我们将整个动画分解为如下部分：</p>

<ul>
<li>A和B绕绿色的轴转动</li>
<li>A和B的父layer，向右运动（保持B与红线始终相接）的同时向后运动（保持B的红边大小不变，中和透视效果）</li>
<li>C按照一定的速率向右运动</li>
</ul>


<p>由于我们需要控制各个layer移动的速度，CABasicAnimation明显不能够满足我们的要求，因此必须使用CAKeyframeAnimation。在代码中你可以看到这个动画的具体实现，关于各种速度的关系，还需针对转动和移动的关系进行一定的数学计算。在实现的过程中还有不少细节需要注意，如果对代码或者整个animation的实现设计有疑问可以留言，我会一一解答。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/27/c-plus-plus-construct-class/">在设计C++的类时我们需要考虑哪些内容</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-27T11:32:33+08:00" pubdate data-updated="true">Apr 27<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>作为一种面向对象的编程语言，类是我们使用C++时频繁使用的单位，由于C++语言的某些特性，与java、Objectivec等语言相比，C++在对多态的实现上有一些不同。java与ObjectiveC是通过runtime来实现多态的，即系统在运行时根据对象的类型来决定，而C++是通过编译时对象的类型来决定调用的函数（C++中的多态是通过指针与virtual 函数来是实现的）。我们先通过例子来看C++与ObjectiveC在多态方面的不同。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//base class</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Shape</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draw</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Shape</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draw</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Shape Draw&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//derived class</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Rectangle</span> : <span class="nc">Shape</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Rectangle</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draw</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Rectangle Draw&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//test</span>
</span><span class='line'><span class="n">Shape</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Shape</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">s</span> <span class="n">draw</span><span class="p">];</span><span class="c1">//will call draw defined in shape</span>
</span><span class='line'><span class="n">Shape</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">r</span> <span class="n">draw</span><span class="p">];</span><span class="c1">//will call draw definied in rectangle</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应的类在C++中定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include&lt;iostream&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Shape</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="o">~</span><span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">draw</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Shape Draw&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Rectangle</span> <span class="o">:</span><span class="k">public</span> <span class="n">Shape</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">draw</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Rectangle Draw&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//test</span>
</span><span class='line'>  <span class="n">Shape</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Shape</span><span class="p">;</span>
</span><span class='line'>  <span class="n">s</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span><span class="c1">//will call draw definied by Shape</span>
</span><span class='line'>  <span class="n">Shape</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="p">;</span>
</span><span class='line'>  <span class="n">r</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span><span class="c1">//will also call draw defined by Shape</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子可以看出来，在C++中，如果函数没有被声明为Virtual，那么通过指针是无法实现多态的。这种机制，带来了代码运行的效率，但是却给我们编码人员提出了更大的要求，我们不能单纯的凭感觉使用c++，使用c++需要我们同时进行思考，将一些必须考虑的内容时刻放在脑子里。</p>

<p>在设计我们自己的类时，我们通常需要审视以下方面的内容（来自C++沉思录）：</p>

<ul>
<li>类中是否需要构造函数</li>
<li>类中成员变量的作用域（private or public）</li>
<li>是否需要定义默认构造函数</li>
<li>是否每一个成员变量都需要在每一个构造函数中初始化</li>
<li>是否需要定义析构函数（*）</li>
<li>是否需要将析构函数定义为Virtual</li>
<li>是否需要定义拷贝构造函数，移动构造函数（*）</li>
<li>是否需要重载赋值操作符（*）</li>
<li>赋值操作符的重载是否正确（是否有效的处理了自赋值情况）（*）</li>
<li>拷贝构造函数和赋值操作符的参数是否确保使用了const限制符（*）</li>
<li>传入引用参数时，是否应该使用const修饰符</li>
</ul>


<p>以上这些条目，应该是我们实现类时需要注意的内容，其中标记<code>*</code>的我们需要进一步解释。</p>

<h4>析构函数、拷贝构造函数、赋值操作符</h4>

<p>析构函数、拷贝构造函数和赋值操作符被称作C++的<code>Big Three</code>,因为通常情况下，如果我们定义了其中一个，我们同样需要定义其他两个。</p>

<p>当我们的类中，具有不能自动释放的资源（通常是一些指针），那么我们需要定义析构函数，在我们的对象析构时，确保资源能够还给系统，从而避免资源的泄露。在这种情况下，<code>我们同样不能够使用系统自己提供的默认的拷贝和赋值的定义</code>。下面的例子可以告诉我们原因：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Shape</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="o">~</span><span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">draw</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Shape Draw&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">changeStr</span><span class="p">(){</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;I am changed&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">printStr</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="c1">//test</span>
</span><span class='line'><span class="n">Shape</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="n">Shape</span> <span class="n">b</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">changeStr</span><span class="p">();</span>
</span><span class='line'><span class="n">s</span><span class="p">.</span><span class="n">printStr</span><span class="p">();</span><span class="c1">//result &quot;I am changed&quot;</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">printStr</span><span class="p">();</span><span class="c1">//result &quot;I am changed&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过结果我们可以看出，系统默认提供的拷贝构造函数和赋值操作符实现了<code>bit-wise</code>的拷贝，拷贝后，例子中的两个对象中的指针成员指向了同样的内存地址，当我们改变一个的内容时，另一个对象的内容也被改变了（基本上这不会是我们希望的）。</p>

<p>因此，在我们实现类时，<code>析构函数</code>，<code>拷贝构造函数</code>，<code>赋值操作符</code>，<code>移动构造函数</code>这四者是息息相关的，我们必须谨慎思考如何适当的实现他们，并且需要确保能够正确和高效的实现，关于他们的实现方法，可以参考之前的一篇<a href="http://dj-chen.com/cn/blog/2014/04/13/c-plus-plus-11-move-semantic/">文章</a>。</p>

<p>关于赋值操作符的重载方式，以及传入引用或者const引用的问题，同样可以参考上面文章中的实现。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/19/ios-concurrent-program1/">iOS并行开发之GCD的使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-19T09:11:24+08:00" pubdate data-updated="true">Apr 19<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在移动App开发中，用户体验是我们在开发过程中必须考虑的问题，实时的相应用户的交互事件，是对一个App最基本的要求，因此程序的并行就显得尤其重要，因此在iOS中，程序的并行并不仅仅是为了加快某些操作的速度，更重要的我们是为了不要阻塞用户在主线程上的交互。iOS提供给我们不同级别的并行的接口，包括NSThread、Grand Central Dispatch（GCD）和NSOperationQueue，来满足我们在不同情形下的需要。</p>

<p>不同的api使用的复杂程度也不同，GCD和NSOperationQueue是建立在NSThread的基础之上，提供给了我们更加高层次的抽象，因此在使用中，我们应该尽量的使用GCD与NSOperationQueu，主要有一下原因：</p>

<ul>
<li>GCD和NSOperationQueue提供给了我们更加友好的接口，使用起来更加方便灵活</li>
<li>GCD和NSOperationQueue仍然是以NSThread为基础来实现的，他们的本质是在系统中维护了一个线程池。当我们放入其中的任务被运行时，运行的单位仍然是线程池中的线程</li>
<li>GCD和NSOperationQueue可以根据系统当前的繁忙状态来决定线程池中可以并发的线程数，这样可以防止过多的线程同时并发，导致系统性能的下降。</li>
</ul>


<p>这里我主要是总结一下并行库的一些知识，还有一个小的<a href="https://github.com/Charlesjean/iOSConcurrentTest">Demo</a>，展示了api的基本用法。</p>

<p>GCD是iOS提供的比较便捷的并行api，我们可以很方便的将包含我们操作的block放在GCD的<code>dispatch queue</code>当中，然后任务就会在线程池中运行。iOS提供给了我们五中不同优先级的dispatch queue，三种不同优先级的背景队列,主线程对应的main queue，以及一个用户IO 操作的背景队列。我们也可以通过系统提供的接口，自己创建新的dispatch queue。</p>

<h4>Dispatch Queue</h4>

<p>一般情况下，系统提供的队列就可以满足我们的要求</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="kt">long</span> <span class="n">priority</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以使用系统api <code>dispatch_queue_create</code>创建自己的队列，并指定队列的类型（串行队列或者并行队列），然后利用<code>dispatch_async</code>或者<code>dispatch_sync</code>将block放入队列中执行，一旦我们将操作放入队列中之后，我们便失去了对这些操作的控制，完全由系统决定他们的实行时间，如果你需要在某些时候取消队列中的操作，那么你需要使用NSOperationQueue。</p>

<h5>多线程时的资源访问的保护</h5>

<p>由于我们的操作在线程池中时并行执行的（除非你的dispatch queue为顺序的），因此如果我们操作中有对资源的写操作，那么我们就需要实现资源的互斥访问，可以通过<code>dispatch_barrier_async</code>来方便的做到这一点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;concurrentQueue&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'><span class="c1">//if we want to add an item to array , and this method is called in blocks in the queue</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">insertString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">str</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">array</span> <span class="nl">addObject:</span><span class="n">str</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>dispatch_barrier_async</code>确保了我们所有的插入操作都是安全的，它确保了<code>addObject</code>语句在queue中所有在其之前插入的block执行完之后才执行。</p>

<h5>Dispatch Group</h5>

<p>Dispatch Group的作用是我们可以集中的处理属于同一group的block，比如我们想要在某几个block全都执行完毕后，将他们的执行结果整合起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//some operation</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//some other operation</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//perform some tasks when all operations are done</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">MyLabel</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="s">@&quot;All operations are done&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>只有当同一group当中的所有block都执行完之后，<code>MyLabel</code>才会发出通知。</p>

<p>GCD还有很多其他的使用和实现的细节，你可以通过<a href="https://developer.apple.com/library/ios/DOCUMENTATION/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyProgrammingGuide.pdf">文档</a>还获得更多的内容</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/16/objectivec-runtime-learning-4/">深入ObjectiveC Runtime之(四)类的加载与Category的实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-16T21:41:24+08:00" pubdate data-updated="true">Apr 16<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>源代码经过编译、连接转化为机器码，在运行时又由runtime加载入内存，因此编译器、连接器和runtime在某种程度上说是协同工作的。在编译过程中，编译器会首先将源代码中的每一个类转换为汇编代码，每一个类的不同的变量，方法等都会被放在汇编代码的不同段当中，然后再将汇编代码转化为机器语言即二进制。为了确保runtime能够对程序进行解析加载，编译器和runtime之间必须有某种约定，以实现runtime对类信息的加载。
例如对于如下的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;objc/Object.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MySuperClass</span>: <span class="nc">Object</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">myMessage1</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MySuperClass</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">myMessage1</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyClass</span>: <span class="nc">MySuperClass</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">myMessage2</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyClass</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">myMessage2</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译成的汇编代码的一部分(无须细读汇编代码)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">.</span><span class="n">file</span>   <span class="s">&quot;test.m&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_CLASS_NAME_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_CLASS_NAME_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_classname,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_CLASS_NAME_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_CLASS_NAME_</span><span class="p">,</span> <span class="mi">13</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_METACLASS_RO_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_const&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_METACLASS_RO_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">1</span>                       <span class="err">#</span> <span class="mh">0x1</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">40</span>                      <span class="err">#</span> <span class="mh">0x28</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">40</span>                      <span class="err">#</span> <span class="mh">0x28</span>
</span><span class='line'>    <span class="p">.</span><span class="n">zero</span>   <span class="mi">4</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_CLASS_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span><span class="p">,</span> <span class="mi">72</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;OBJC_METACLASS_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_data&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">globl</span>  <span class="n">OBJC_METACLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">OBJC_METACLASS_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_cache</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_vtable</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span><span class="p">,</span> <span class="mi">40</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_METH_VAR_NAME_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_methname,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_METH_VAR_NAME_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;myMessage1&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span><span class="p">,</span> <span class="mi">11</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_METH_VAR_TYPE_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_methtype,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_METH_VAR_TYPE_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;v16@0:8&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span><span class="p">,</span> <span class="mi">8</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_$_INSTANCE_METHODS_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_const&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_$_INSTANCE_METHODS_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">24</span>                      <span class="err">#</span> <span class="mh">0x18</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">1</span>                       <span class="err">#</span> <span class="mh">0x1</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_2D__5B_MySuperClass_20_myMessage1_5D_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span><span class="p">,</span> <span class="mi">32</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_CLASS_RO_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_CLASS_RO_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">0</span>                       <span class="err">#</span> <span class="mh">0x0</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">8</span>                       <span class="err">#</span> <span class="mh">0x8</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">8</span>                       <span class="err">#</span> <span class="mh">0x8</span>
</span><span class='line'>    <span class="p">.</span><span class="n">zero</span>   <span class="mi">4</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_CLASS_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span><span class="p">,</span> <span class="mi">72</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">OBJC_CLASS_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;OBJC_CLASS_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_data&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">globl</span>  <span class="n">OBJC_CLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">OBJC_CLASS_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_CLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_cache</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_vtable</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">OBJC_CLASS_$_MySuperClass</span><span class="p">,</span> <span class="mi">40</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编译得到的汇编代码中，不同的代码段对应ObjectiveC runtime中不同类型的数据结构。</p>

<p><code>main</code>函数通常是我们认为的程序的入口，但是实际上，在进程刚刚开始执行时，<code>_objc_init</code>函数会在<code>main</code>函数之前被调用，在<code>_objc_init</code>函数中我们看到如下语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dyld_register_image_state_change_handler</span><span class="p">(</span><span class="n">dyld_image_state_bound</span><span class="p">,</span>
</span><span class='line'>                                             <span class="mi">1</span><span class="cm">/*batch*/</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_images</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>即在<code>_objc_init</code>时，runtime调用了<code>map_images</code>方法，<code>map_images</code>中又调用了<code>map_images_nolock</code>方法，继续下去我们会发现，程序调用了名为<code>realizeAllClasses</code>的方法，并最终在<code>static Class realizeClass(Class cls)</code>中具体实现了对某一个类的加载。</p>

<p>在<code>static Class realizeClass(Class cls)</code>中，系统实现了对类<code>cls</code>的初始化，包括为类对象分配空间，生成类的函数列表等。在这里我们以Category的实现为例。</p>

<p>我们可以在<code>static void methodizeClass(Class cls)</code>方法中看到对<code>static void attachCategoryMethods</code>的调用，这个方法就是我们要找的category的实现原理所在：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">attachCategoryMethods</span><span class="p">(</span><span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">category_list</span> <span class="o">*</span><span class="n">cats</span><span class="p">,</span> <span class="n">bool</span> <span class="n">flushCaches</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cats</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">PrintReplacedMethods</span><span class="p">)</span> <span class="n">printReplacements</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">bool</span> <span class="n">isMeta</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">isMetaClass</span><span class="p">();</span>
</span><span class='line'>    <span class="n">method_list_t</span> <span class="o">**</span><span class="n">mlists</span> <span class="o">=</span> <span class="p">(</span><span class="n">method_list_t</span> <span class="o">**</span><span class="p">)</span>
</span><span class='line'>        <span class="n">_malloc_internal</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mlists</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Count backwards through cats to get newest categories first</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">fromBundle</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">mlist</span> <span class="o">=</span> <span class="n">cat_method_list</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cat</span><span class="p">,</span> <span class="n">isMeta</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">mlists</span><span class="p">[</span><span class="n">mcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>
</span><span class='line'>            <span class="n">fromBundle</span> <span class="o">|=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fromBundle</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">attachMethodLists</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">mlists</span><span class="p">,</span> <span class="n">mcount</span><span class="p">,</span> <span class="n">NO</span><span class="p">,</span> <span class="n">fromBundle</span><span class="p">,</span> <span class="n">flushCaches</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">_free_internal</span><span class="p">(</span><span class="n">mlists</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数第一个参数为当前正加载的类，第二个参数为对应类的所有的category的实现，在方法中，程序遍历了所有的category，将所有的在category中定义的函数，放在<code>mlists</code>中，然后利用<code>attachMethodLists</code>方法将category中添加的方法整合到类的method list当中，从而实现了category这一语言特性。</p>

<p>代码并不复杂，关键是我们在月的的过程中要慢慢找到函数间的调用层次，类加载这一部分的函数调用层次如下所示：
<img src="https://raw.githubusercontent.com/Charlesjean/cn/master/source/_posts/Category.png" alt="" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/13/c-plus-plus-11-move-semantic/">C++11之Move 构造函数和Move 赋值操作符</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-13T11:19:04+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Move语义是C++11中为了提高性能，减少临时对象的构造和析构而引入的新的语义环境，和Move语义相关的还有右值引用(rvalue reference)，这里我们总结一下，Move语义的引入带来了哪些好处，当我们定义一个类时需要注意什么。</p>

<h4>Move语义及移动构造函数</h4>

<p>我们通过代码来看一下Move语义出现的原因及必要性。</p>

<p>假设我们有如下的类定义，TestClass类中含有一个<code>Char*</code>类型的成员变量，为了实现内存的管理，按照<code>The Big Three</code>原则，我们需要为这个类定义<code>拷贝构造函数</code>，<code>析构函数</code>和<code>赋值操作符</code>。类的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">TestClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">_array</span><span class="p">)</span> <span class="o">:</span> <span class="n">array_pointer</span><span class="p">(</span><span class="n">_array</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Constructor Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">TestClass</span><span class="p">(){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Destructor is InVoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Copy Constructor is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
</span><span class='line'>      <span class="n">memcpy</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">char</span><span class="o">*</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>拷贝构造函数</code>的语义为：当我们采用一个对象A去构造新的对象时，拷贝构造函数会被自动调用。拷贝构造函数的参数为<code>const TestClass&amp; rhs</code>决定了我们无法改变rhs的值。在下列情况下会使用拷贝构造函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">TestClass</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="n">TestClass</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于对象A的构造，拷贝构造函数完全符合我们的期望，因为我们使用了一个    <code>lvalue</code>来构造A，我们不希望改变<code>x</code>的内容，以便以后继续保持对<code>x</code>的引用。但是对于对象B的构造过程，拷贝构造函数明显做了多余的事情：</p>

<blockquote><p>  我们采用<code>rvalue</code>即一个临时变量来构造B，在B构造之后，临时变量会被销毁，我们不需要保持对这个临时变量的引用。因此，我们完全可以直接将构造函数中参数<code>rhs</code>的<code>array_pointer</code>指针直接给B，这样一来就可以省下B中<code>array_pointer</code>的初始化以及临时变量中<code>array_pointer</code>的释放过程。</p></blockquote>

<p>我们通过代码来进一步理解：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span><span class="c1">//directly assign pointer in rhs to the new object</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span><span class="c1">//do not let rhs refer to the raw pointer any more</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码就是我们所说的<code>Move Semantic</code>，当使用<code>rvalue</code>去构造或者给一个对象赋值时,我们可以直接将<code>rvalue</code>中的指针直接转移给新的对象，从而节省新的内存分配等的开销,由于<code>rvalue</code>在新的对象构造之后会被自动释放，所以我们没有必要保留对它的引用。</p>

<p>在C++11之前我们无法将上面的代码块写入构造函数中，因为我们无法区分<code>rhs</code>是不是<code>rvalue</code>。C++11中引入了右值引用，允许我们实现针对右值引用的函数重载（只在参数类型 指定右值即可），代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//This is move consturctor, transfer ownership</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//notice there are two &#39;&amp;&#39; symbols</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Move Construct is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面就是移动构造函数（Move Constructor）,函数参数为<code>TestClass&amp;&amp;</code>，表明函数接受一个<code>rvalue</code>。</p>

<p>实现移动构造函数应注意两点:</p>

<ul>
<li>参数类型为TestClass&amp;&amp;</li>
<li>需要取消rhs中指针对原地址的引用（防止在rhs析构时导致原变量被释放）</li>
</ul>


<h4>移动赋值运算符</h4>

<p>了解了移动构造函数，很自然的想到在对对象进行赋值运算时同样存在<code>rvalue</code>的问题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">A</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="n">B</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样我们可以重载移动赋值操作符如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//move assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(1)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(2)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">TestClass</span> <span class="n">tmp</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们重载了两个<code>operator=</code>操作符，当我们对<code>A</code>赋值时,(2)会被调用，当我们对<code>B</code>赋值时，(1)会被调用。</p>

<p>在c++11中你可以采用上述做法，重载两个对应复制操作符的函数，也可以使用下面更简洁的方法(unifying assignment operator)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把函数的参数改成按值传递的形式（），这样做的好处有：
*   如果我们是以一个<code>lvalue</code>对对象进行赋值，那么系统会自动构建一个对象的拷贝作为函数的参数（因为是按值传递的）
*   如果我们是以一个<code>rvalue</code>对对象进行赋值，那么这个函数的表现会像（1）一样。</p>

<p>关于赋值操作符的重载可以参考<a href="http://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap">这篇文章</a>。</p>

<p>这里有一个<a href="https://github.com/Charlesjean/C11TestProjects">demo project</a>,有兴趣的话可以下来看一下代码。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/cn/blog/2014/04/09/objectivec-runtime-learning-3/">深入ObjectiveC Runtime之(三)NSObject类与NSObject接口</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-09T20:05:43+08:00" pubdate data-updated="true">Apr 9<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在学习ObjectiveC Runtime代码是你会发现，在系统中除了一个名为NSObject的类之外，还存在一个同样名字为NSObject的接口（Protocol），这不禁让我们有疑问，NSObject接口存在的原因是什么，同样的名字难道不会有冲突吗？</p>

<p>我们先看一下接口 NSObject的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@protocol</span> <span class="nc">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">self</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nf">zone</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object1</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isProxy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isKindOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMemberOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span><span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">aProtocol</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">respondsToSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">retain</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">oneway</span> <span class="kt">void</span><span class="p">)</span><span class="nf">release</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">retainCount</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span><span class="p">;</span>
</span><span class='line'><span class="k">@optional</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">debugDescription</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们平时使用的runtime类型判断接口，以及<code>performSelector</code>等都定义在以NSObject为名的Protocol当中。这些方法在我们平时的编程过程中被大量使用，基本上所有的类都可以respond to这些方法，而我们的类都是继承自NSObject的，他们为什么会有NSObject Protocol当中声明的方法呢，唯一的解释就是<code>Class NSObject 实现了 NSObject Protocol</code>，在runtime的代码中我们也可以得到印证</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span>  <span class="n">OBJC_ISA_AVAILABILITY</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上在ObjectiveC中，interface和protocol的名字是可以相同的，因为在语言中不存在任何可以产生歧义的语法，也就是说interface和protocol使用于完全不同的语法环境，因此可以有相同的名字。</p>

<p>我们还可以进一步思考NSObject Protocol存在的必要性。在JAVA中，所有的类都是java.lang.Object的子类（Object是唯一的ROOT Class），而ObjectiveC中并不是所有的类都是NSObject的子类（有些类继承自NSProxy而不是NSObject）。因此在ObjectiveC中，为了给所有的类提供某些通用的接口，就必须保证所有的ROOT Class，都去实现某一个Protocol，NSObject Protocol就因此诞生，即<code>所有的root class，包括NSObject和NSProxy都会实现NSObject Protocol</code>， 我想这才是NSObject Protocol存在的根本原因。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/cn/blog/page/2/">&larr; 前一页</a>
    
    <a href="/cn/blog/archives">文章列表</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
 <h1>Archives</h1>
 <ul id="categories">
  <li class='category'><a href='/cn/blog/categories/android/'>Android(4)</a></li>
<li class='category'><a href='/cn/blog/categories/c-plus-plus/'>C_Plus_Plus(3)</a></li>
<li class='category'><a href='/cn/blog/categories/objectivec/'>ObjectiveC(4)</a></li>
<li class='category'><a href='/cn/blog/categories/octopress/'>Octopress(1)</a></li>
<li class='category'><a href='/cn/blog/categories/ios/'>iOS(2)</a></li>

  </ul>
  </section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/cn/blog/2014/05/26/android-art-vs-dalvik/">Android ART 与 Dalvik虚拟机比较</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/05/22/nexus5-windows-debug/">解决Windows下Android Device Manager无法找到Nexus5</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/05/20/goagent-android-sdk-download/">解决Android SDK Manager无法下载SDK的问题</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/05/17/c-plus-plus-11-new-feature/">C++11 常用新语言特性总结</a>
      </li>
    
      <li class="post">
        <a href="/cn/blog/2014/05/02/core-animation/">iOS中Core Animation的使用</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Visitors</h1>
  <script type="text/javascript" src="http://ji.revolvermaps.com/2/1.js?i=89aid7d1ejy&amp;s=220&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Duanjin Chen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
