<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keep it Simple and Stupid]]></title>
  <link href="http://Charlesjean.github.io//cn/atom.xml" rel="self"/>
  <link href="http://Charlesjean.github.io//cn/"/>
  <updated>2014-04-19T10:33:04+08:00</updated>
  <id>http://Charlesjean.github.io//cn/</id>
  <author>
    <name><![CDATA[Duanjin Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS并行开发之GCD的使用]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/19/ios-concurrent-program1/"/>
    <updated>2014-04-19T09:11:24+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/19/ios-concurrent-program1</id>
    <content type="html"><![CDATA[<p>在移动App开发中，用户体验是我们在开发过程中必须考虑的问题，实时的相应用户的交互事件，是对一个App最基本的要求，因此程序的并行就显得尤其重要，因此在iOS中，程序的并行并不仅仅是为了加快某些操作的速度，更重要的我们是为了不要阻塞用户在主线程上的交互。iOS提供给我们不同级别的并行的接口，包括NSThread、Grand Central Dispatch（GCD）和NSOperationQueue，来满足我们在不同情形下的需要。</p>

<p>不同的api使用的复杂程度也不同，GCD和NSOperationQueue是建立在NSThread的基础之上，提供给了我们更加高层次的抽象，因此在使用中，我们应该尽量的使用GCD与NSOperationQueu，主要有一下原因：</p>

<ul>
<li>GCD和NSOperationQueue提供给了我们更加友好的接口，使用起来更加方便灵活</li>
<li>GCD和NSOperationQueue仍然是以NSThread为基础来实现的，他们的本质是在系统中维护了一个线程池。当我们放入其中的任务被运行时，运行的单位仍然是线程池中的线程</li>
<li>GCD和NSOperationQueue可以根据系统当前的繁忙状态来决定线程池中可以并发的线程数，这样可以防止过多的线程同时并发，导致系统性能的下降。</li>
</ul>


<p>这里我主要是总结一下并行库的一些知识，还有一个小的<a href="https://github.com/Charlesjean/iOSConcurrentTest">Demo</a>，展示了api的基本用法。</p>

<p>GCD是iOS提供的比较便捷的并行api，我们可以很方便的将包含我们操作的block放在GCD的<code>dispatch queue</code>当中，然后任务就会在线程池中运行。iOS提供给了我们五中不同优先级的dispatch queue，三种不同优先级的背景队列,主线程对应的main queue，以及一个用户IO 操作的背景队列。我们也可以通过系统提供的接口，自己创建新的dispatch queue。</p>

<h4>Dispatch Queue</h4>

<p>一般情况下，系统提供的队列就可以满足我们的要求</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="kt">long</span> <span class="n">priority</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以使用系统api <code>dispatch_queue_create</code>创建自己的队列，并指定队列的类型（串行队列或者并行队列），然后利用<code>dispatch_async</code>或者<code>dispatch_sync</code>将block放入队列中执行，一旦我们将操作放入队列中之后，我们便失去了对这些操作的控制，完全由系统决定他们的实行时间，如果你需要在某些时候取消队列中的操作，那么你需要使用NSOperationQueue。</p>

<h5>多线程时的资源访问的保护</h5>

<p>由于我们的操作在线程池中时并行执行的（除非你的dispatch queue为顺序的），因此如果我们操作中有对资源的写操作，那么我们就需要实现资源的互斥访问，可以通过<code>dispatch_barrier_async</code>来方便的做到这一点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;concurrentQueue&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'><span class="c1">//if we want to add an item to array , and this method is called in blocks in the queue</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">insertString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">str</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">array</span> <span class="nl">addObject:</span><span class="n">str</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>dispatch_barrier_async</code>确保了我们所有的插入操作都是安全的，它确保了<code>addObject</code>语句在queue中所有在其之前插入的block执行完之后才执行。</p>

<h5>Dispatch Group</h5>

<p>Dispatch Group的作用是我们可以集中的处理属于同一group的block，比如我们想要在某几个block全都执行完毕后，将他们的执行结果整合起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//some operation</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//some other operation</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//perform some tasks when all operations are done</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">MyLabel</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="s">@&quot;All operations are done&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>只有当同一group当中的所有block都执行完之后，<code>MyLabel</code>才会发出通知。</p>

<p>GCD还有很多其他的使用和实现的细节，你可以通过<a href="https://developer.apple.com/library/ios/DOCUMENTATION/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyProgrammingGuide.pdf">文档</a>还获得更多的内容</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之(四)类的加载与Category的实现]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/16/objectivec-runtime-learning-4/"/>
    <updated>2014-04-16T21:41:24+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/16/objectivec-runtime-learning-4</id>
    <content type="html"><![CDATA[<p>源代码经过编译、连接转化为机器码，在运行时又由runtime加载入内存，因此编译器、连接器和runtime在某种程度上说是协同工作的。在编译过程中，编译器会首先将源代码中的每一个类转换为汇编代码，每一个类的不同的变量，方法等都会被放在汇编代码的不同段当中，然后再将汇编代码转化为机器语言即二进制。为了确保runtime能够对程序进行解析加载，编译器和runtime之间必须有某种约定，以实现runtime对类信息的加载。
例如对于如下的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;objc/Object.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MySuperClass</span>: <span class="nc">Object</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">myMessage1</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MySuperClass</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">myMessage1</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyClass</span>: <span class="nc">MySuperClass</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">myMessage2</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyClass</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">myMessage2</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译成的汇编代码的一部分(无须细读汇编代码)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">.</span><span class="n">file</span>   <span class="s">&quot;test.m&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_CLASS_NAME_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_CLASS_NAME_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_classname,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_CLASS_NAME_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_CLASS_NAME_</span><span class="p">,</span> <span class="mi">13</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_METACLASS_RO_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_const&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_METACLASS_RO_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">1</span>                       <span class="err">#</span> <span class="mh">0x1</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">40</span>                      <span class="err">#</span> <span class="mh">0x28</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">40</span>                      <span class="err">#</span> <span class="mh">0x28</span>
</span><span class='line'>    <span class="p">.</span><span class="n">zero</span>   <span class="mi">4</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_CLASS_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span><span class="p">,</span> <span class="mi">72</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;OBJC_METACLASS_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_data&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">globl</span>  <span class="n">OBJC_METACLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">OBJC_METACLASS_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_cache</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_vtable</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span><span class="p">,</span> <span class="mi">40</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_METH_VAR_NAME_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_methname,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_METH_VAR_NAME_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;myMessage1&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span><span class="p">,</span> <span class="mi">11</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_METH_VAR_TYPE_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_methtype,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_METH_VAR_TYPE_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;v16@0:8&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span><span class="p">,</span> <span class="mi">8</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_$_INSTANCE_METHODS_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_const&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_$_INSTANCE_METHODS_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">24</span>                      <span class="err">#</span> <span class="mh">0x18</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">1</span>                       <span class="err">#</span> <span class="mh">0x1</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_2D__5B_MySuperClass_20_myMessage1_5D_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span><span class="p">,</span> <span class="mi">32</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_CLASS_RO_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_CLASS_RO_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">0</span>                       <span class="err">#</span> <span class="mh">0x0</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">8</span>                       <span class="err">#</span> <span class="mh">0x8</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">8</span>                       <span class="err">#</span> <span class="mh">0x8</span>
</span><span class='line'>    <span class="p">.</span><span class="n">zero</span>   <span class="mi">4</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_CLASS_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span><span class="p">,</span> <span class="mi">72</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">OBJC_CLASS_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;OBJC_CLASS_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_data&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">globl</span>  <span class="n">OBJC_CLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">OBJC_CLASS_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_CLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_cache</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_vtable</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">OBJC_CLASS_$_MySuperClass</span><span class="p">,</span> <span class="mi">40</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编译得到的汇编代码中，不同的代码段对应ObjectiveC runtime中不同类型的数据结构。</p>

<p><code>main</code>函数通常是我们认为的程序的入口，但是实际上，在进程刚刚开始执行时，<code>_objc_init</code>函数会在<code>main</code>函数之前被调用，在<code>_objc_init</code>函数中我们看到如下语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dyld_register_image_state_change_handler</span><span class="p">(</span><span class="n">dyld_image_state_bound</span><span class="p">,</span>
</span><span class='line'>                                             <span class="mi">1</span><span class="cm">/*batch*/</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_images</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>即在<code>_objc_init</code>时，runtime调用了<code>map_images</code>方法，<code>map_images</code>中又调用了<code>map_images_nolock</code>方法，继续下去我们会发现，程序调用了名为<code>realizeAllClasses</code>的方法，并最终在<code>static Class realizeClass(Class cls)</code>中具体实现了对某一个类的加载。</p>

<p>在<code>static Class realizeClass(Class cls)</code>中，系统实现了对类<code>cls</code>的初始化，包括为类对象分配空间，生成类的函数列表等。在这里我们以Category的实现为例。</p>

<p>我们可以在<code>static void methodizeClass(Class cls)</code>方法中看到对<code>static void attachCategoryMethods</code>的调用，这个方法就是我们要找的category的实现原理所在：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">attachCategoryMethods</span><span class="p">(</span><span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">category_list</span> <span class="o">*</span><span class="n">cats</span><span class="p">,</span> <span class="n">bool</span> <span class="n">flushCaches</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cats</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">PrintReplacedMethods</span><span class="p">)</span> <span class="n">printReplacements</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">bool</span> <span class="n">isMeta</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">isMetaClass</span><span class="p">();</span>
</span><span class='line'>    <span class="n">method_list_t</span> <span class="o">**</span><span class="n">mlists</span> <span class="o">=</span> <span class="p">(</span><span class="n">method_list_t</span> <span class="o">**</span><span class="p">)</span>
</span><span class='line'>        <span class="n">_malloc_internal</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mlists</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Count backwards through cats to get newest categories first</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">fromBundle</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">mlist</span> <span class="o">=</span> <span class="n">cat_method_list</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cat</span><span class="p">,</span> <span class="n">isMeta</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">mlists</span><span class="p">[</span><span class="n">mcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>
</span><span class='line'>            <span class="n">fromBundle</span> <span class="o">|=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fromBundle</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">attachMethodLists</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">mlists</span><span class="p">,</span> <span class="n">mcount</span><span class="p">,</span> <span class="n">NO</span><span class="p">,</span> <span class="n">fromBundle</span><span class="p">,</span> <span class="n">flushCaches</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">_free_internal</span><span class="p">(</span><span class="n">mlists</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数第一个参数为当前正加载的类，第二个参数为对应类的所有的category的实现，在方法中，程序遍历了所有的category，将所有的在category中定义的函数，放在<code>mlists</code>中，然后利用<code>attachMethodLists</code>方法将category中添加的方法整合到类的method list当中，从而实现了category这一语言特性。</p>

<p>代码并不复杂，关键是我们在月的的过程中要慢慢找到函数间的调用层次，类加载这一部分的函数调用层次如下所示：
<img src="https://raw.githubusercontent.com/Charlesjean/cn/master/source/_posts/Category.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11之Move 构造函数和Move 赋值操作符]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/13/c-plus-plus-11-move-semantic/"/>
    <updated>2014-04-13T11:19:04+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/13/c-plus-plus-11-move-semantic</id>
    <content type="html"><![CDATA[<p>Move语义是C++11中为了提高性能，减少临时对象的构造和析构而引入的新的语义环境，和Move语义相关的还有右值引用(rvalue reference)，这里我们总结一下，Move语义的引入带来了哪些好处，当我们定义一个类时需要注意什么。</p>

<h4>Move语义及移动构造函数</h4>

<p>我们通过代码来看一下Move语义出现的原因及必要性。</p>

<p>假设我们有如下的类定义，TestClass类中含有一个<code>Char*</code>类型的成员变量，为了实现内存的管理，按照<code>The Big Three</code>原则，我们需要为这个类定义<code>拷贝构造函数</code>，<code>析构函数</code>和<code>赋值操作符</code>。类的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">TestClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">_array</span><span class="p">)</span> <span class="o">:</span> <span class="n">array_pointer</span><span class="p">(</span><span class="n">_array</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Constructor Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">TestClass</span><span class="p">(){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Destructor is InVoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Copy Constructor is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
</span><span class='line'>      <span class="n">memcpy</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">char</span><span class="o">*</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>拷贝构造函数</code>的语义为：当我们采用一个对象A去构造新的对象时，拷贝构造函数会被自动调用。拷贝构造函数的参数为<code>const TestClass&amp; rhs</code>决定了我们无法改变rhs的值。在下列情况下会使用拷贝构造函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">TestClass</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="n">TestClass</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于对象A的构造，拷贝构造函数完全符合我们的期望，因为我们使用了一个    <code>lvalue</code>来构造A，我们不希望改变<code>x</code>的内容，以便以后继续保持对<code>x</code>的引用。但是对于对象B的构造过程，拷贝构造函数明显做了多余的事情：</p>

<blockquote><p>  我们采用<code>rvalue</code>即一个临时变量来构造B，在B构造之后，临时变量会被销毁，我们不需要保持对这个临时变量的引用。因此，我们完全可以直接将构造函数中参数<code>rhs</code>的<code>array_pointer</code>指针直接给B，这样一来就可以省下B中<code>array_pointer</code>的初始化以及临时变量中<code>array_pointer</code>的释放过程。</p></blockquote>

<p>我们通过代码来进一步理解：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span><span class="c1">//directly assign pointer in rhs to the new object</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span><span class="c1">//do not let rhs refer to the raw pointer any more</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码就是我们所说的<code>Move Semantic</code>，当使用<code>rvalue</code>去构造或者给一个对象赋值时,我们可以直接将<code>rvalue</code>中的指针直接转移给新的对象，从而节省新的内存分配等的开销,由于<code>rvalue</code>在新的对象构造之后会被自动释放，所以我们没有必要保留对它的引用。</p>

<p>在C++11之前我们无法将上面的代码块写入构造函数中，因为我们无法区分<code>rhs</code>是不是<code>rvalue</code>。C++11中引入了右值引用，允许我们实现针对右值引用的函数重载（只在参数类型 指定右值即可），代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//This is move consturctor, transfer ownership</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//notice there are two &#39;&amp;&#39; symbols</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Move Construct is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面就是移动构造函数（Move Constructor）,函数参数为<code>TestClass&amp;&amp;</code>，表明函数接受一个<code>rvalue</code>。</p>

<p>实现移动构造函数应注意两点:</p>

<ul>
<li>参数类型为TestClass&amp;&amp;</li>
<li>需要取消rhs中指针对原地址的引用（防止在rhs析构时导致原变量被释放）</li>
</ul>


<h4>移动赋值运算符</h4>

<p>了解了移动构造函数，很自然的想到在对对象进行赋值运算时同样存在<code>rvalue</code>的问题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">A</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="n">B</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样我们可以重载移动赋值操作符如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//move assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(1)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(2)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">TestClass</span> <span class="n">tmp</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们重载了两个<code>operator=</code>操作符，当我们对<code>A</code>赋值时,(2)会被调用，当我们对<code>B</code>赋值时，(1)会被调用。</p>

<p>在c++11中你可以采用上述做法，重载两个对应复制操作符的函数，也可以使用下面更简洁的方法(unifying assignment operator)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把函数的参数改成按值传递的形式（），这样做的好处有：
*   如果我们是以一个<code>lvalue</code>对对象进行赋值，那么系统会自动构建一个对象的拷贝作为函数的参数（因为是按值传递的）
*   如果我们是以一个<code>rvalue</code>对对象进行赋值，那么这个函数的表现会像（1）一样。</p>

<p>关于赋值操作符的重载可以参考<a href="http://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap">这篇文章</a>。</p>

<p>这里有一个<a href="https://github.com/Charlesjean/C11TestProjects">demo project</a>,有兴趣的话可以下来看一下代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之(三)NSObject类与NSObject接口]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/09/objectivec-runtime-learning-3/"/>
    <updated>2014-04-09T20:05:43+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/09/objectivec-runtime-learning-3</id>
    <content type="html"><![CDATA[<p>在学习ObjectiveC Runtime代码是你会发现，在系统中除了一个名为NSObject的类之外，还存在一个同样名字为NSObject的接口（Protocol），这不禁让我们有疑问，NSObject接口存在的原因是什么，同样的名字难道不会有冲突吗？</p>

<p>我们先看一下接口 NSObject的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@protocol</span> <span class="nc">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">self</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nf">zone</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object1</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isProxy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isKindOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMemberOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span><span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">aProtocol</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">respondsToSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">retain</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">oneway</span> <span class="kt">void</span><span class="p">)</span><span class="nf">release</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">retainCount</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span><span class="p">;</span>
</span><span class='line'><span class="k">@optional</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">debugDescription</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们平时使用的runtime类型判断接口，以及<code>performSelector</code>等都定义在以NSObject为名的Protocol当中。这些方法在我们平时的编程过程中被大量使用，基本上所有的类都可以respond to这些方法，而我们的类都是继承自NSObject的，他们为什么会有NSObject Protocol当中声明的方法呢，唯一的解释就是<code>Class NSObject 实现了 NSObject Protocol</code>，在runtime的代码中我们也可以得到印证</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span>  <span class="n">OBJC_ISA_AVAILABILITY</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上在ObjectiveC中，interface和protocol的名字是可以相同的，因为在语言中不存在任何可以产生歧义的语法，也就是说interface和protocol使用于完全不同的语法环境，因此可以有相同的名字。</p>

<p>我们还可以进一步思考NSObject Protocol存在的必要性。在JAVA中，所有的类都是java.lang.Object的子类（Object是唯一的ROOT Class），而ObjectiveC中并不是所有的类都是NSObject的子类（有些类继承自NSProxy而不是NSObject）。因此在ObjectiveC中，为了给所有的类提供某些通用的接口，就必须保证所有的ROOT Class，都去实现某一个Protocol，NSObject Protocol就因此诞生，即<code>所有的root class，包括NSObject和NSProxy都会实现NSObject Protocol</code>， 我想这才是NSObject Protocol存在的根本原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之（二）安装Clang]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/03/objectivec-runtime-learning-2/"/>
    <updated>2014-04-03T21:20:48+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/03/objectivec-runtime-learning-2</id>
    <content type="html"><![CDATA[<p>在<a href="http://dj-chen.com/cn/blog/2014/03/26/objectivec-runtime-learning-1/">上一篇</a>中我们通过阅读代码，了解了ObjectiveC的内部对象模型的实现，接下来我们继续通过代码来了解ObjectiveC是如何加载一个类，以及ObjectiveC是如何实现对Category的支持的。</p>

<p>我们需要利用Clang来生成一部分中间代码，帮助我们了解runtime的运行机制，因此我们首先需要安装Clang。</p>

<p>Clang是LLVM的前端，可以用来编译C，C++，ObjectiveC等语言。传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。Clang则是以LLVM为后端的一款高效易用，并且与IDE结合很好的编译前端。</p>

<p>我们需要自己下载LLVM与Clang源代码进行编译，步骤如下：</p>

<figure class='code'><figcaption><span>lang=shell </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm 
</span><span class='line'>
</span><span class='line'>cd llvm/tools 
</span><span class='line'>svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
</span><span class='line'>cd ../..
</span><span class='line'>
</span><span class='line'>cd llvm/projects
</span><span class='line'>svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt
</span><span class='line'>cd ../..
</span><span class='line'>
</span><span class='line'>mkdir build 
</span><span class='line'>cd build
</span><span class='line'>../llvm/configure
</span><span class='line'>make</span></code></pre></td></tr></table></div></figure>


<p>至此，Clang 安装完毕，你可以使用<code>clang --help</code>来验证是否正确安装。</p>

<p>工欲善其事必先利其器，安装Clang主要是为我们今后的学习做准备，我本身对编译器没有特别深入的学习，如果你对Clang感兴趣可以<a href="http://clang.llvm.org/">参考这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android通过代码设置控件点击时颜色变化]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/03/30/android-statelistdrawable-and-colorstatelist/"/>
    <updated>2014-03-30T12:54:00+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/03/30/android-statelistdrawable-and-colorstatelist</id>
    <content type="html"><![CDATA[<p>在UI设计时，我们通常希望用户得到及时的交互反馈，例如在按钮上发生点击事件，或者textView上发生点击时，我们通常采用highlight一个控件的方法，提醒用户点击事件的发生。我们通常会通过改变控件的背景颜色或者字体的颜色来达到高亮的效果，Android提供了两个类，StateListDrawable和ColorStateList来支持这种操作。</p>

<p>在Android的<a href="http://developer.android.com/guide/topics/resources/color-list-resource.html">官方文档</a>以及网上很多资料中，我们可以看到这种高亮的支持都会通过编写xml来实现的。个人认为xml的实现方式虽然简单、可复用，但是如果我们有很多种状态，或者要动态的产生不同的颜色效果，那么XML的方式会使我们的工程中增加很多的resource文件，作为一个Programmer我更喜欢通过代码来达到相同的目的。本文所用的例子比较简单，仅仅是对一个textview做了高亮设置，当用户点击textiew时，会改变其背景色和字体颜色，可以在<a href="https://github.com/Charlesjean/FragmentTest">这里</a>下载代码。关键代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    *Add statedrawable for targetView to display different drawable when</span>
</span><span class='line'><span class="cm">    * view is in different state</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addStateDrawable</span><span class="o">(</span><span class="n">View</span> <span class="n">targetView</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">StateListDrawable</span> <span class="n">listDrawable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateListDrawable</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//add drawable used when view is pressed</span>
</span><span class='line'>        <span class="n">listDrawable</span><span class="o">.</span><span class="na">addState</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">android</span><span class="o">.</span><span class="na">R</span><span class="o">.</span><span class="na">attr</span><span class="o">.</span><span class="na">state_pressed</span><span class="o">},</span> <span class="k">new</span> <span class="n">ColorDrawable</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">rgb</span><span class="o">(</span><span class="mi">106</span><span class="o">,</span><span class="mi">170</span><span class="o">,</span><span class="mi">234</span><span class="o">)));</span>
</span><span class='line'>        <span class="c1">//show gray background for all other state</span>
</span><span class='line'>        <span class="n">listDrawable</span><span class="o">.</span><span class="na">addState</span><span class="o">(</span><span class="n">StateSet</span><span class="o">.</span><span class="na">WILD_CARD</span><span class="o">,</span> <span class="k">new</span> <span class="n">ColorDrawable</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">GRAY</span><span class="o">));</span>
</span><span class='line'>        <span class="n">targetView</span><span class="o">.</span><span class="na">setBackgroundDrawable</span><span class="o">(</span><span class="n">listDrawable</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * set different text color for different state</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addColorState</span><span class="o">(</span><span class="n">TextView</span> <span class="n">targetView</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">states</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">android</span><span class="o">.</span><span class="na">R</span><span class="o">.</span><span class="na">attr</span><span class="o">.</span><span class="na">state_pressed</span><span class="o">},</span>
</span><span class='line'>                <span class="n">StateSet</span><span class="o">.</span><span class="na">WILD_CARD</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">colors</span> <span class="o">=</span> <span class="o">{</span><span class="n">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">,</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">};</span>
</span><span class='line'>        <span class="n">ColorStateList</span> <span class="n">coloList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ColorStateList</span><span class="o">(</span><span class="n">states</span><span class="o">,</span> <span class="n">colors</span><span class="o">);</span>
</span><span class='line'>        <span class="n">targetView</span><span class="o">.</span><span class="na">setTextColor</span><span class="o">(</span><span class="n">coloList</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>StateListDrawable 提供了<code>addState</code>接口，使我们能够对应每一种状态，设置一个drawable；ColorStateList同样使我们为每一种状态指定一种字体颜色。 其中<code>StateSet.WILD_CARD</code>表示去除当前已有状态外的其他所有状态。</p>

<p>所谓状态就是指随着用户的交互，View所出的不同的状态。 其中<code>state_pressed</code>表示<code>when the user is pressing down in a view.</code>,更多对状态的描述可以参考<a href="http://developer.android.com/reference/android/graphics/drawable/StateListDrawable.html">android 文档</a> (个人认为android的很多文档写得很烂，完全是对字面意思的解释，这一点与iOS根本无法相比)。</p>

<h3>使用StateListDrawable和ColorStateList需要注意的事项</h3>

<ul>
<li>首先由于控件的状态是随着用户的点击等事件而改变的，所以要想使之前的代码能起作用，我们必须确保view能够接受用户的点击事件，最基本的必须用<code>setClickable(true)</code>,使控件可以点击</li>
<li>由于android对点击等事件的传递有一定的规则，要使<code>StateListDrawable</code>和<code>ColorStateList</code>起作用，最根本上要保证view的<strong>onTouchEvent</strong>函数能够被调用到，即TouchEvent不能被其他的对象 如<code>ParentView</code>和<code>TouchListener</code>所截断。(如果view注册了EventListener那么事件就会在传给onTouchEvent()函数之前，被EventListener截断)。</li>
</ul>


<p>关于Android中事件的传递机制，可以参考<a href="">这篇文章</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之对象模型]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/03/26/objectivec-runtime-learning-1/"/>
    <updated>2014-03-26T07:36:12+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/03/26/objectivec-runtime-learning-1</id>
    <content type="html"><![CDATA[<p>ObjectiveC与C++同样是在C的基础上对C的扩展，但与C++相比，我认为ObjectiveC提供了更加强大的功能，比如Category，forward message, method-swiazzing, KVO以及一些runtime接口，而所有这些技术都是以ObjectiveC强大的Runtime为基础的。因此只有深入学习了runtime的机制，才能使我们对OC的使用更加得心应手， 并且对于大多数runtime技术，我们必须在熟悉它的底层实现机制后才能够达到正确使用的目的，否则的话你将陷入痛苦的debug之中。</p>

<p>对象模型是程序运行时对象在内存中的组织方式，由于ObjectiveC是OOP的编程语言，对象模型就涉及到<code>类的组织方式</code>,<code>继承关系的表示方法</code>，<code>成员变量与函数的存储方式</code>，<code>如何实现RTTI</code>等，因此对象模型是我们了解ObjectiveC runtime技术实现机制的基础。</p>

<h3>ObjectiveC中对象的数据结构</h3>

<p>我们都知道，ObjectiveC中的大多数类都是NSObject的子类，因此我们先从NSObject的结构开始,在NSObject.h中我们可以看到如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NS_ROOT_CLASS</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span>  <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>NSObject类中只有一个名为<code>isa</code>的<code>Class</code>类型的变量，跳转到<code>Class</code>的定义我们可以看到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_class</span> <span class="o">*</span><span class="n">Class</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Class</code>为指向<code>objc_class</code>的指针，而<code>objc_class</code>就代表了在Objectivec中一个类的定义。其源代码定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_class</span> <span class="o">:</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Class ISA;</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">superclass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cache_t</span> <span class="n">cache</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们看到<code>objc_class</code>继承自<code>objc_object</code>,而<code>objc_object</code>的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="n">uintptr_t</span> <span class="n">isa</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc_object只保存了一个<code>isa</code>指针，在原代码中我们还可以看到</p>

<pre><code>typedef struct objc_object *id;
</code></pre>

<p>看到这里一切应该都已经明了了。我们知道在ObjectiveC中每一个对象都是一个<code>id</code>,所以<code>objc_object</code>就是我们每一个对象在内存中的结构，它保存了一个指向<code>objc_class</code>的指针，这个指针就指向对象所对应的类在内存中的位置。</p>

<p>既然<code>objc_class</code>代表了ObjectiveC中的类，那么结构中必然需要存储类的相关信息，包括类的名字，成员函数的位置等信息，在ObjectiveC2.0中，这些信息被封装在了<code>class_rw_t</code>和<code>class_ro_t</code>当中，他们代码定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">class_rw_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">version</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">class_ro_t</span> <span class="o">*</span><span class="n">ro</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">**</span><span class="n">method_lists</span><span class="p">;</span>  <span class="c1">// RW_METHOD_ARRAY == 1</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">method_list</span><span class="p">;</span>    <span class="c1">// RW_METHOD_ARRAY == 0</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">chained_property_list</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">protocol_list_t</span> <span class="o">**</span> <span class="n">protocols</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Class</span> <span class="n">firstSubclass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">nextSiblingClass</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">class_ro_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">instanceStart</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">instanceSize</span><span class="p">;</span>
</span><span class='line'><span class="cp">#ifdef __LP64__</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">uint8_t</span> <span class="o">*</span> <span class="n">ivarLayout</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">method_list_t</span> <span class="o">*</span> <span class="n">baseMethods</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">protocol_list_t</span> <span class="o">*</span> <span class="n">baseProtocols</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">ivar_list_t</span> <span class="o">*</span> <span class="n">ivars</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">uint8_t</span> <span class="o">*</span> <span class="n">weakIvarLayout</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">property_list_t</span> <span class="o">*</span><span class="n">baseProperties</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此我们基本上了解了ObjectiveC中对象的组织形式，总结如下：</p>

<blockquote><p>每一个ObjectiveC对象都保存了一个<code>isa</code>指针指向其所对应的类的实现<code>objc_class</code>，而<code>objc_class</code>中保存了类父类，名称，函数列表，以及Protocol等信息。</p></blockquote>

<p>但是有些内容还不是特别清晰：</p>

<blockquote><ul>
<li>对象的成员变量应该是局部于对象的，不应该保存在<code>objc_class</code>中，对于成员变量这部分的实现还不清晰</li>
<li>对于大部分文章中提到的<code>元类</code>在代码中是如何体现的？ 目前我在代码中没有看到</li>
</ul>
</blockquote>

<p>以上ObjectiveC基本的对象模型，在这个对象模型的基础上ObjectiveC提供给了我们丰富的Runtime特性以及OO的支持，以后我们会进一步深入了解一些重要特性的实现。</p>

<p>我阅读的代码版本是Objc4-551，是官方开源的最新代码，如果文章中有错误或者有更详尽的看法请留言，共同学习进步。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Github托管的Octopress个人博客]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/03/25/personal-blog-with-github-and-octopress/"/>
    <updated>2014-03-25T07:33:30+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/03/25/personal-blog-with-github-and-octopress</id>
    <content type="html"><![CDATA[<p>   Github Pages 一直是自己喜爱的博客形式，之前托管了一个简单的英文博客，直接将博客的源代码放在username.github.io项目下，
代码管理简单，但是需要github在访问时将Jeklly转换为静态的网页，未免会带来网站性能的损失。Octopress 提供了更好的管理博客的方法，并集成了更多可以使用的插件和自动化的功能，这个中文博客就是基于Octopress，仍然托管在Github上，不过不是以个人网页的形式，而是以project pages的形式托管.</p>

<p>  在部署octopress的时候，会遇到不少问题，这里主要来记录一下，以备以后使用.</p>

<h4>fatal：remote origin already exists</h4>

<p>我的配置环境为reby 1.9.3， 在根据Octopress的<a href="http://octopress.org/docs/setup/">官方文档</a>安装主题之后，并在github上建立好新的repository之后，执行rake setup_github_pages会出错，提示</p>

<pre><code>remote origin already exists
</code></pre>

<p>解决方法：将Octopress/Rakefile中357行</p>

<pre><code>git remote add origin #{repo_url} 改为 git remote set-url origin #{repo_url}
</code></pre>

<h4>修改相应的配置文件</h4>

<p>由于现在的中文博客是放在github的一个project上，目的是为了实现如下方式访问：username.github.io/project,所以我们需要修改一下Octopress的配置文件，来指明目录结构。</p>

<ul>
<li>_config.yml:修改url,root,destination</li>
<li>config.rb:修改http_path,http_image_path,http_fonts_path,css_dir</li>
</ul>


<p>具体的改变可以参考<a href="https://github.com/Charlesjean/cn">这里</a>相对应的文件。</p>

<h4>UTF-8或者GB2312编码问题</h4>

<p>在执行rake generate命令之后，如果遇到 invalid byte sequence UTF-8 等错误，说明在你的文件当中有非法的编码字符，这些字符可能是由于我们使用的编辑器默认添加的一些字符，这里我们首先推荐使用nodepad++或者markdown专用的编辑器。</p>

<p>解决方法：</p>

<ul>
<li>修改Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-0.12.1\lib\jekyll\convertible.rb， 改变如下</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.content = File.read(File.join(base, name),:encoding=>"utf-8")</span></code></pre></td></tr></table></div></figure>


<ul>
<li>利用nodepad++找出非法字符，并将文档编码设置为utf-8 without BOM</li>
</ul>


<p>上面基本上列出了我在搭建过程中遇到的问题，喜欢用github搭建博客的都起码有一些编程能力，相信大家应该都可以很好地解决这些基本的问题，也欢迎大家反映自己遇到的问题，我们一起讨论解决。</p>

<p>再一次感谢Github提供了如此简单，可靠，关键还是免费的搭建博客的支持:)</p>
]]></content>
  </entry>
  
</feed>
