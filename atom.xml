<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keep it Simple and Stupid]]></title>
  <link href="http://Charlesjean.github.io//cn/atom.xml" rel="self"/>
  <link href="http://Charlesjean.github.io//cn/"/>
  <updated>2014-05-22T22:00:53+08:00</updated>
  <id>http://Charlesjean.github.io//cn/</id>
  <author>
    <name><![CDATA[Duanjin Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解决Windows下Android Device Manager无法找到Nexus5]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/05/22/nexus5-windows-debug/"/>
    <updated>2014-05-22T21:50:49+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/05/22/nexus5-windows-debug</id>
    <content type="html"><![CDATA[<p>一直用公司的MAC开发Android，在将Nexus5连接到自己的Windows上时，发现ADT中无法找到Nexus5，adb devices命令也无法检测到设备，虽然设备能够以磁盘的方式显示在Windows Explorer中，但是似乎设备的驱动仍然没有正确的安装：</p>

<ul>
<li>打开windows 设备管理器可以发现，Nexus5设备标识上有一黄色叹号，表示驱动没有正确安装</li>
<li>下载Nexus5 <a href="http://developer.android.com/sdk/win-usb.html#top">设备驱动</a>，并解压至某一目录</li>
<li>在设备管理器中，右键点击设备，并更新驱动</li>
<li>选中刚才解压的目录，即可正确的安装驱动</li>
</ul>


<p>Issue Fixed ：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决Android SDK Manager无法下载SDK的问题]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/05/20/goagent-android-sdk-download/"/>
    <updated>2014-05-20T22:31:33+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/05/20/goagent-android-sdk-download</id>
    <content type="html"><![CDATA[<p>计算机应用可以说是少数国内与国外技术差别比较小的领域，主要原因是网络的帮助，使我们很方便的看到国外的技术文档与很多优秀的文章，但是很多时候国内的环境确实令人非常气愤，居然Android SDK网站都会被墙，以至于Android SDK Manager根本无法下载。解决方法是安装并打开goagent，并将SDK Manager的Proxy设置为<code>127.0.0.1:8087</code>。如果不知道goagent的话，那就好好搜索一下吧，国内的环境，基本上这个是必备的了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11 常用新语言特性总结]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/05/17/c-plus-plus-11-new-feature/"/>
    <updated>2014-05-17T14:07:31+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/05/17/c-plus-plus-11-new-feature</id>
    <content type="html"><![CDATA[<p>C++11给我们提供了很多新的特性，相比于C++98，C++11在很多地方使用起来更加顺手，很多新的特性让C++变得更加让人喜欢，对编码人员更加友好，很多规则更加统一。在这些新的特性当中，有很多高级特性，比如关于模板的特性（个人真的很少在开发中用到）；也有很多确确实实方便了开发，而且使c++代码更加整洁、安全、快速的特性。在学习中总结一下，往往可以在使用过程中更加得心应手。</p>

<h4>auto</h4>

<p>c++11中auto关键字和c++98中有完全的不同，在c++11中，如果我们把变量声明为auto，那么编译器会自动根据上下文推断出变量的类型，因此在很多情况下，特别是类型比较长的时候，我们可以使用auto来使代码更加整洁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="p">.....</span>
</span><span class='line'>
</span><span class='line'><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="c1">//get iterator of vector,do not need to use vector&lt;String&gt;::iterator</span>
</span></code></pre></td></tr></table></div></figure>


<p>乍一看，这仅仅是提供了一些编程上的方便，但是实际上在很多类型不确定的时候，auto提供了更大的帮助</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">multiply</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">vt</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">vu</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">vt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">vu</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//here it&#39;s hard to decide type of tmp, auto saves us a lot</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>智能指针</h4>

<p>在c++11中，智能指针使用起来更加顺手，相比于之前的auto_ptr, unique_ptr和shared_ptr更加容易的和stl容器一起使用。unique_ptr顾名思义为独有指针，被unique_ptr包含的指针在任意时刻只能有一个unique_ptr拥有，任何对unique_ptr的赋值和拷贝都会产生指针的移动；shared_ptr是实现了引用计数的智能指针，相对于unique_ptr，shared_ptr需要维护一个计数对象，因此在赋值和拷贝时，较unique_ptr会产生更大的开销。weak_ptr是用来避免循环引用。（在另一篇文章中，我们会比较这几种智能指针的使用）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">gadget</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">widget</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">gadget</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">;</span> <span class="c1">// if shared ownership</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">gadget</span> <span class="p">{</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">;</span><span class="c1">//avoid cycle reference</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h4>nullptr</h4>

<p>在C++11中我们可以使用nullptr来指定一个指针为空，而不再使用0 或者NULL。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'><span class="kt">char</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//do not use this any more, if you use, p==p2 is still ok</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//for function</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="c1">//will call f(int)</span>
</span><span class='line'><span class="n">f</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span><span class="c1">//will call f(char*)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Range for</h4>

<p>c++11中也引入了更加有好的for循环语法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="c1">//c++98 </span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//c++11</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">audo</span> <span class="n">d</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Range-for语法不仅适用于stl容器，还可以用于string, array。</p>

<h4>不需使用容器的begin和end成员函数</h4>

<p>begin()和end()方法不仅仅可以用于stl 容器，还可以用于数组当中，看如下的对比代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class='line'><span class="c1">//c++98</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//c++11</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>对比如此明显，你还会用原来的语法吗？</p>

<h4>Move Semantic</h4>

<p>可以参考<a href="http://dj-chen.com/cn/blog/2014/04/13/c-plus-plus-11-move-semantic/">这篇文章</a></p>

<h4>类成员变量的初始化</h4>

<p>在c++11中允许我们在声明成员变量时给出初始化，避免了需要在所有的构造函数中提供变量的初始化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>      <span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>      <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a_val</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a_val</span><span class="p">)</span> <span class="p">{}</span><span class="c1">//a_aval will replace 7</span>
</span><span class='line'>      <span class="n">A</span><span class="p">(</span><span class="n">D</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">b</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="p">{}</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span><span class="c1">//this is ok</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span><span class="c1">//this is ok</span>
</span><span class='line'>  <span class="k">private</span><span class="o">:</span>
</span><span class='line'>      <span class="n">HashingFunction</span> <span class="n">hash_algorithm</span><span class="p">{</span><span class="s">&quot;MD5&quot;</span><span class="p">};</span>  <span class="c1">// Cryptographic hash to be applied to all A instances</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="s">&quot;Constructor run&quot;</span><span class="p">};</span>       <span class="c1">// String indicating state in object lifecycle</span>
</span><span class='line'>    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h4>托管构造</h4>

<p>C++11允许我们托管构造，即在一个构造函数中调用另一个构造函数，实现类状态的初始化，避免了我们之前经常需要自己实现一个Init函数，然后在各个构造函数中调用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="k">public</span><span class="o">:</span>
</span><span class='line'>      <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="o">&lt;</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">max</span><span class="p">)</span> <span class="n">a</span><span class="o">=</span><span class="n">x</span><span class="p">;</span> <span class="k">else</span> <span class="k">throw</span> <span class="n">bad_X</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'>      <span class="n">X</span><span class="p">()</span> <span class="o">:</span><span class="n">X</span><span class="p">{</span><span class="mi">42</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>      <span class="n">X</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span><span class="n">X</span><span class="p">{</span><span class="n">lexical_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">)}</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++11还有许多其他的新的特性或者语法，这里只是自己平时用到的，觉得比较实用的，欢迎大家提出自己喜欢的新特性。对于C++11中的lambda语法，我个人不是太喜欢，因为不是特别容易调试:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中Core Animation的使用]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/05/02/core-animation/"/>
    <updated>2014-05-02T21:26:21+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/05/02/core-animation</id>
    <content type="html"><![CDATA[<p>用户体验是用户在使用一款软件和系统时，对软件和系统能得到的最直观的感受，iOS一直因为良好的用户体验而受到大家的赞赏，流畅的操作和丰富的动画无疑给iOS的用户体验加了不少分。对于我们编程人员来说，iOS中提供了强大的Core Animation库，并封装了友好的API，使我们能够实现复杂的动画效果。</p>

<p>Core Animation提供了两种动画的类型，并封装成类CABasicAnimation和CAKeyframeAnimation，我们需要针对自己的目标来选择使用这两种类。动画的实现过程实际上就是在一定时间内连续播放一系列的视频帧，在iOS中要求60帧/秒，通常情况下，我们实现动画的做法是给出动画在一定时间内的<code>关键帧</code>，然后利用<code>差值</code>的方法得到关键帧之间的所有帧序列的状态。CABasicAnimation 和 CAKeyframeAnimation的最大区别就是</p>

<blockquote><pre><code>  CABasicAnimation要求我们只能提供动画的第一帧和最后一帧，然后系统利用我们指定的插值方法，计算出整个动画的所有序列；
    而利用CAKeyframeAnimation我们可以给出动画过程中的多个关键帧，然后同样系统利用我们制定的插值方法，计算出连续的两个关键帧之间的所有序列，从而实现动画。 
    可以看到，利用CAKeyframeAnimation，我们对动画有更多的控制权，因此大多数比较复杂的动画也需要选用CAKeyframeAnimation。
</code></pre></blockquote>

<p>我在<a href="https://github.com/Charlesjean/CoreAnimationDemo">demo</a>中实现了两种动画效果，动画并不算复杂，但是却能很好的了解这两种动画类的使用，并且由于动画是作用在CALayer之上，因此CALayer的相关知识也是我们能够正确的使用Core Animation的基础，在例子中你也可以看到一些CALayer的属性，如anchor point，transform等是如何使用的。demo的效果如下：
<video width='' height='' preload='none' controls poster=''><source src='https://raw.githubusercontent.com/Charlesjean/CoreAnimationDemo/master/demo.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'></video></p>

<p>当我们在屏幕上滑动时，view controller会移除当前view（currentView），并添加新的view（nextView），并通过动画来达到比较优美的效果。Demo中含有两种动画效果，当我们像左滑动时，触发了folder animation，当我们向右滑时触发了accordion animation。</p>

<h4>Render tree 和 Presentation tree</h4>

<p>CALayer与UIView类似，对于一个有UIView组成的View Hierarchy，同样也有一个对应的Layer Hierarchy。但是Layer Hierarchy又对应两种不同的树结构，我们称作Render tree 和 Presentation tree，理解了render tree和presentation tree后，有利于我们解决动画过程当中的某些问题（在动画开始和结束时候的可能出现的闪烁问题）。</p>

<p>我们以一个例子来解释这两个概念。
在CALayer中很多属性是可以触发动画的，我们看如下简单代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="n">layer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在layer的背景色被改变后，我们可以看到动画中layer的颜色会由原来的颜色，慢慢过渡为红色。在动画中我们看到的layer的状态（颜色随时间而变化）就是presentation tree中layer的状态，而当动画结束后，layer最终呈现的状态就是render tree中的状态。换句话说，动画中我们改变的是presentation tree中layer的状态，而不是layer最终呈现的状态，如果我们将改变颜色的一个CABasicAnimation对象作用到layer上，动画会呈现出来（presentation tree）而layer在动画结束的瞬间仍然会变回原来的颜色（render tree）。</p>

<h4>Folder Animation</h4>

<p>Folder动画给我们的感觉是类似翻书的效果，要实现这个动画我们首先需要考虑如何将动画分解，及动画中我们将涉及到CALayer的布局如何，我们实现动画所需要改变的属性是什么。按照folder动画的效果，我们可以将这个动画分解为下图所示：</p>

<p><img src="https://raw.githubusercontent.com/Charlesjean/cn/master/source/_posts/folder.png" alt="" /></p>

<p>直观上我们可以看到图中包含了三个CALayer，黄色的leftLayer，绿色的rightLayer，已经处于旋转状态的rotateLayer。动画的整个过程就是rotateLayer绕Y轴旋转180度的过程。</p>

<p>folder动画应该满足的要求为：
*   rotateLayer在旋转的时候应该有透视（Perspective）的效果
*   rotateLayer似乎有两个面，正面显示的内容为currentView的右半部分，反面显示的为nextView的左半部分</p>

<p>查看代码，在FolderAnimation.mm中，我们可以看到以下的变量声明</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">FolderAnimation</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CATransformLayer</span><span class="o">*</span> <span class="n">animationLayer</span><span class="p">;</span><span class="c1">//rotateLayer</span>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">frontAnimationLayer</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">backAnimationLayer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">currentViewHalfLayer</span><span class="p">;</span><span class="c1">//leftLayer</span>
</span><span class='line'>    <span class="n">CALayer</span><span class="o">*</span> <span class="n">nextViewHalfLayer</span><span class="p">;</span><span class="c1">//rightLayer</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们实际需要使用5个Layer来完成这个动画，其中需要旋转并带有透视效果的layer我们选择的是CATransformLayer，在CATransformLayer上，我们需要放置两个CALayer，作为它的&#8221;正面&#8221;和&#8221;反面&#8221;。</p>

<p>CALayer的绘制是二维的，也就是说在将CALayer的整个Layer Hierarchy绘制到屏幕上之前，CALayer当中所有的layer都会被先绘制到一张bitmap上面，然后系统再将这张bitmap显示出来。这种绘制方式决定了，我们的要求2无法满足，也就是说一个layer不可能有两个不同的面，这种情况下我们就需要使用CATransformLayer。CATransformLayer允许我们建立三维的Layer Hierarchy，也就是说它的所有的Sub Layer存在于一个三维的空间内，我们可以对他们进行旋转、平移等操作，也正是由于CATransformLayer模拟了三维的空间，所以它可以提供给我们透视（perspective）的效果（具体可以参见CATransformLayer的文档）。</p>

<p>建立好了用于动画的Layer Hierarchy之后，下一步就是要向rotateLayer添加动画，因为本例中只涉及了一个转动的动画，所以我们选择使用CABasicAnimation</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>    <span class="n">CABasicAnimation</span><span class="o">*</span> <span class="n">animation</span> <span class="o">=</span> <span class="p">[</span><span class="n">CABasicAnimation</span> <span class="nl">animationWithKeyPath:</span><span class="s">@&quot;transform&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CATransform3D</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DIdentity</span><span class="p">;</span>
</span><span class='line'>    <span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DRotate</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span>  <span class="n">direction</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">transform</span><span class="p">.</span><span class="n">m34</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">*</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">1000</span><span class="p">;</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSValue</span> <span class="nl">valueWithCATransform3D:</span><span class="n">transform</span><span class="p">];</span>
</span><span class='line'>    <span class="n">animation</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">duration</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">animationLayer</span> <span class="nl">addAnimation:</span><span class="n">animation</span> <span class="nl">forKey:</span><span class="n">Nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>动画的代码比较简单，我们将图中的rotateLayer旋转了180度，需要注意的有两点：</p>

<ul>
<li>1.transform.m34的设置是为了产生透视效果，至于transform的意义涉及到图形学中的视图投影矩阵的内容，会在另一篇文章中阐述</li>
<li>2.animation.delegate的设置是为了监听动画的结束，以便做一些动画结束时的工作（保证presentation tree的最后状态与render tree一致）。</li>
</ul>


<h4>Accordion Animation</h4>

<p>相对于folder animation来说accordion animation的实现要复杂许多。
下图示意了Accordion的过程：</p>

<p><img src="https://raw.githubusercontent.com/Charlesjean/cn/master/source/_posts/accordition.png" alt="" /></p>

<p>其中A、B、C为“表面上”看起来需要做动画的Layer，在C向右<code>移动</code>的过程中，A和B需要一边向右<code>移动</code>一边绕轴<code>转动</code>,再仔细想一下，还有以下要求：</p>

<ul>
<li> 1.A和B在转动的过程中需要有透视的效果,即A和B的父Layer需要是一个CATransformLayer</li>
<li> 2.移动与转动过程中A 与 C需要一直保持邻接，即A的边在X方向的移动速度要与C的移动速度相同</li>
<li> 3.在移动和转动过程中A 与 B需要一直保持邻接，A与B在X方向上具有相同的移动速度</li>
<li> 4.B的最右边，即红色的线，需要保持不变，B的红边须保持“不动”</li>
</ul>


<p>相对于folder动画，accordion不再是只在某一个layer上实现动画，而是多个layer结合起来实现动画，而且过程中多了许多限制条件。
我们将整个动画分解为如下部分：</p>

<ul>
<li>A和B绕绿色的轴转动</li>
<li>A和B的父layer，向右运动（保持B与红线始终相接）的同时向后运动（保持B的红边大小不变，中和透视效果）</li>
<li>C按照一定的速率向右运动</li>
</ul>


<p>由于我们需要控制各个layer移动的速度，CABasicAnimation明显不能够满足我们的要求，因此必须使用CAKeyframeAnimation。在代码中你可以看到这个动画的具体实现，关于各种速度的关系，还需针对转动和移动的关系进行一定的数学计算。在实现的过程中还有不少细节需要注意，如果对代码或者整个animation的实现设计有疑问可以留言，我会一一解答。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在设计C++的类时我们需要考虑哪些内容]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/27/c-plus-plus-construct-class/"/>
    <updated>2014-04-27T11:32:33+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/27/c-plus-plus-construct-class</id>
    <content type="html"><![CDATA[<p>作为一种面向对象的编程语言，类是我们使用C++时频繁使用的单位，由于C++语言的某些特性，与java、Objectivec等语言相比，C++在对多态的实现上有一些不同。java与ObjectiveC是通过runtime来实现多态的，即系统在运行时根据对象的类型来决定，而C++是通过编译时对象的类型来决定调用的函数（C++中的多态是通过指针与virtual 函数来是实现的）。我们先通过例子来看C++与ObjectiveC在多态方面的不同。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//base class</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Shape</span> : <span class="nc">NSObject</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draw</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Shape</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draw</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Shape Draw&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//derived class</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">Rectangle</span> : <span class="nc">Shape</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Rectangle</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">draw</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Rectangle Draw&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//test</span>
</span><span class='line'><span class="n">Shape</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Shape</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">s</span> <span class="n">draw</span><span class="p">];</span><span class="c1">//will call draw defined in shape</span>
</span><span class='line'><span class="n">Shape</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Rectangle</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">r</span> <span class="n">draw</span><span class="p">];</span><span class="c1">//will call draw definied in rectangle</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应的类在C++中定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include&lt;iostream&gt;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Shape</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="o">~</span><span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">draw</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Shape Draw&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Rectangle</span> <span class="o">:</span><span class="k">public</span> <span class="n">Shape</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">draw</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Rectangle Draw&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//test</span>
</span><span class='line'>  <span class="n">Shape</span><span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Shape</span><span class="p">;</span>
</span><span class='line'>  <span class="n">s</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span><span class="c1">//will call draw definied by Shape</span>
</span><span class='line'>  <span class="n">Shape</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rectangle</span><span class="p">;</span>
</span><span class='line'>  <span class="n">r</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span><span class="c1">//will also call draw defined by Shape</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子可以看出来，在C++中，如果函数没有被声明为Virtual，那么通过指针是无法实现多态的。这种机制，带来了代码运行的效率，但是却给我们编码人员提出了更大的要求，我们不能单纯的凭感觉使用c++，使用c++需要我们同时进行思考，将一些必须考虑的内容时刻放在脑子里。</p>

<p>在设计我们自己的类时，我们通常需要审视以下方面的内容（来自C++沉思录）：</p>

<ul>
<li>类中是否需要构造函数</li>
<li>类中成员变量的作用域（private or public）</li>
<li>是否需要定义默认构造函数</li>
<li>是否每一个成员变量都需要在每一个构造函数中初始化</li>
<li>是否需要定义析构函数（*）</li>
<li>是否需要将析构函数定义为Virtual</li>
<li>是否需要定义拷贝构造函数，移动构造函数（*）</li>
<li>是否需要重载赋值操作符（*）</li>
<li>赋值操作符的重载是否正确（是否有效的处理了自赋值情况）（*）</li>
<li>拷贝构造函数和赋值操作符的参数是否确保使用了const限制符（*）</li>
<li>传入引用参数时，是否应该使用const修饰符</li>
</ul>


<p>以上这些条目，应该是我们实现类时需要注意的内容，其中标记<code>*</code>的我们需要进一步解释。</p>

<h4>析构函数、拷贝构造函数、赋值操作符</h4>

<p>析构函数、拷贝构造函数和赋值操作符被称作C++的<code>Big Three</code>,因为通常情况下，如果我们定义了其中一个，我们同样需要定义其他两个。</p>

<p>当我们的类中，具有不能自动释放的资源（通常是一些指针），那么我们需要定义析构函数，在我们的对象析构时，确保资源能够还给系统，从而避免资源的泄露。在这种情况下，<code>我们同样不能够使用系统自己提供的默认的拷贝和赋值的定义</code>。下面的例子可以告诉我们原因：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Shape</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="o">~</span><span class="n">Shape</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">draw</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Shape Draw&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">changeStr</span><span class="p">(){</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;I am changed&quot;</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">printStr</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="c1">//test</span>
</span><span class='line'><span class="n">Shape</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="n">Shape</span> <span class="n">b</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">changeStr</span><span class="p">();</span>
</span><span class='line'><span class="n">s</span><span class="p">.</span><span class="n">printStr</span><span class="p">();</span><span class="c1">//result &quot;I am changed&quot;</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">printStr</span><span class="p">();</span><span class="c1">//result &quot;I am changed&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过结果我们可以看出，系统默认提供的拷贝构造函数和赋值操作符实现了<code>bit-wise</code>的拷贝，拷贝后，例子中的两个对象中的指针成员指向了同样的内存地址，当我们改变一个的内容时，另一个对象的内容也被改变了（基本上这不会是我们希望的）。</p>

<p>因此，在我们实现类时，<code>析构函数</code>，<code>拷贝构造函数</code>，<code>赋值操作符</code>，<code>移动构造函数</code>这四者是息息相关的，我们必须谨慎思考如何适当的实现他们，并且需要确保能够正确和高效的实现，关于他们的实现方法，可以参考之前的一篇<a href="http://dj-chen.com/cn/blog/2014/04/13/c-plus-plus-11-move-semantic/">文章</a>。</p>

<p>关于赋值操作符的重载方式，以及传入引用或者const引用的问题，同样可以参考上面文章中的实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS并行开发之GCD的使用]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/19/ios-concurrent-program1/"/>
    <updated>2014-04-19T09:11:24+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/19/ios-concurrent-program1</id>
    <content type="html"><![CDATA[<p>在移动App开发中，用户体验是我们在开发过程中必须考虑的问题，实时的相应用户的交互事件，是对一个App最基本的要求，因此程序的并行就显得尤其重要，因此在iOS中，程序的并行并不仅仅是为了加快某些操作的速度，更重要的我们是为了不要阻塞用户在主线程上的交互。iOS提供给我们不同级别的并行的接口，包括NSThread、Grand Central Dispatch（GCD）和NSOperationQueue，来满足我们在不同情形下的需要。</p>

<p>不同的api使用的复杂程度也不同，GCD和NSOperationQueue是建立在NSThread的基础之上，提供给了我们更加高层次的抽象，因此在使用中，我们应该尽量的使用GCD与NSOperationQueu，主要有一下原因：</p>

<ul>
<li>GCD和NSOperationQueue提供给了我们更加友好的接口，使用起来更加方便灵活</li>
<li>GCD和NSOperationQueue仍然是以NSThread为基础来实现的，他们的本质是在系统中维护了一个线程池。当我们放入其中的任务被运行时，运行的单位仍然是线程池中的线程</li>
<li>GCD和NSOperationQueue可以根据系统当前的繁忙状态来决定线程池中可以并发的线程数，这样可以防止过多的线程同时并发，导致系统性能的下降。</li>
</ul>


<p>这里我主要是总结一下并行库的一些知识，还有一个小的<a href="https://github.com/Charlesjean/iOSConcurrentTest">Demo</a>，展示了api的基本用法。</p>

<p>GCD是iOS提供的比较便捷的并行api，我们可以很方便的将包含我们操作的block放在GCD的<code>dispatch queue</code>当中，然后任务就会在线程池中运行。iOS提供给了我们五中不同优先级的dispatch queue，三种不同优先级的背景队列,主线程对应的main queue，以及一个用户IO 操作的背景队列。我们也可以通过系统提供的接口，自己创建新的dispatch queue。</p>

<h4>Dispatch Queue</h4>

<p>一般情况下，系统提供的队列就可以满足我们的要求</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="kt">long</span> <span class="n">priority</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们也可以使用系统api <code>dispatch_queue_create</code>创建自己的队列，并指定队列的类型（串行队列或者并行队列），然后利用<code>dispatch_async</code>或者<code>dispatch_sync</code>将block放入队列中执行，一旦我们将操作放入队列中之后，我们便失去了对这些操作的控制，完全由系统决定他们的实行时间，如果你需要在某些时候取消队列中的操作，那么你需要使用NSOperationQueue。</p>

<h5>多线程时的资源访问的保护</h5>

<p>由于我们的操作在线程池中时并行执行的（除非你的dispatch queue为顺序的），因此如果我们操作中有对资源的写操作，那么我们就需要实现资源的互斥访问，可以通过<code>dispatch_barrier_async</code>来方便的做到这一点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;concurrentQueue&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'><span class="c1">//if we want to add an item to array , and this method is called in blocks in the queue</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">insertString:</span><span class="p">(</span><span class="n">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">str</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">array</span> <span class="nl">addObject:</span><span class="n">str</span><span class="p">];</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>dispatch_barrier_async</code>确保了我们所有的插入操作都是安全的，它确保了<code>addObject</code>语句在queue中所有在其之前插入的block执行完之后才执行。</p>

<h5>Dispatch Group</h5>

<p>Dispatch Group的作用是我们可以集中的处理属于同一group的block，比如我们想要在某几个block全都执行完毕后，将他们的执行结果整合起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//some operation</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="n">queue</span><span class="p">,</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="c1">//some other operation</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//perform some tasks when all operations are done</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">MyLabel</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="s">@&quot;All operations are done&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>只有当同一group当中的所有block都执行完之后，<code>MyLabel</code>才会发出通知。</p>

<p>GCD还有很多其他的使用和实现的细节，你可以通过<a href="https://developer.apple.com/library/ios/DOCUMENTATION/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyProgrammingGuide.pdf">文档</a>还获得更多的内容</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之(四)类的加载与Category的实现]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/16/objectivec-runtime-learning-4/"/>
    <updated>2014-04-16T21:41:24+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/16/objectivec-runtime-learning-4</id>
    <content type="html"><![CDATA[<p>源代码经过编译、连接转化为机器码，在运行时又由runtime加载入内存，因此编译器、连接器和runtime在某种程度上说是协同工作的。在编译过程中，编译器会首先将源代码中的每一个类转换为汇编代码，每一个类的不同的变量，方法等都会被放在汇编代码的不同段当中，然后再将汇编代码转化为机器语言即二进制。为了确保runtime能够对程序进行解析加载，编译器和runtime之间必须有某种约定，以实现runtime对类信息的加载。
例如对于如下的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;objc/Object.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MySuperClass</span>: <span class="nc">Object</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">myMessage1</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MySuperClass</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">myMessage1</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyClass</span>: <span class="nc">MySuperClass</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">myMessage2</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyClass</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">myMessage2</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译成的汇编代码的一部分(无须细读汇编代码)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">.</span><span class="n">file</span>   <span class="s">&quot;test.m&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_CLASS_NAME_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_CLASS_NAME_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_classname,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_CLASS_NAME_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_CLASS_NAME_</span><span class="p">,</span> <span class="mi">13</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_METACLASS_RO_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_const&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_METACLASS_RO_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">1</span>                       <span class="err">#</span> <span class="mh">0x1</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">40</span>                      <span class="err">#</span> <span class="mh">0x28</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">40</span>                      <span class="err">#</span> <span class="mh">0x28</span>
</span><span class='line'>    <span class="p">.</span><span class="n">zero</span>   <span class="mi">4</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_CLASS_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span><span class="p">,</span> <span class="mi">72</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;OBJC_METACLASS_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_data&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">globl</span>  <span class="n">OBJC_METACLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">OBJC_METACLASS_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_cache</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_vtable</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_METACLASS_RO_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span><span class="p">,</span> <span class="mi">40</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_METH_VAR_NAME_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_methname,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_METH_VAR_NAME_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;myMessage1&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span><span class="p">,</span> <span class="mi">11</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">L_OBJC_METH_VAR_TYPE_&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__TEXT,__objc_methtype,cstring_literals&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'><span class="nl">L_OBJC_METH_VAR_TYPE_:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">asciz</span>   <span class="s">&quot;v16@0:8&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span><span class="p">,</span> <span class="mi">8</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_$_INSTANCE_METHODS_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_const&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_$_INSTANCE_METHODS_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">24</span>                      <span class="err">#</span> <span class="mh">0x18</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">1</span>                       <span class="err">#</span> <span class="mh">0x1</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_METH_VAR_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_METH_VAR_TYPE_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_2D__5B_MySuperClass_20_myMessage1_5D_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span><span class="p">,</span> <span class="mi">32</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;</span><span class="se">\01</span><span class="s">l_OBJC_CLASS_RO_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">l_OBJC_CLASS_RO_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">0</span>                       <span class="err">#</span> <span class="mh">0x0</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">8</span>                       <span class="err">#</span> <span class="mh">0x8</span>
</span><span class='line'>    <span class="p">.</span><span class="kt">long</span>   <span class="mi">8</span>                       <span class="err">#</span> <span class="mh">0x8</span>
</span><span class='line'>    <span class="p">.</span><span class="n">zero</span>   <span class="mi">4</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">L_OBJC_CLASS_NAME_</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_$_INSTANCE_METHODS_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="mi">0</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span><span class="p">,</span> <span class="mi">72</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">.</span><span class="n">type</span>   <span class="n">OBJC_CLASS_$_MySuperClass</span><span class="p">,</span><span class="err">@</span><span class="n">object</span> <span class="err">#</span> <span class="s">@&quot;OBJC_CLASS_$_MySuperClass&quot;</span>
</span><span class='line'>    <span class="p">.</span><span class="n">section</span>    <span class="s">&quot;__DATA, __objc_data&quot;</span><span class="p">,</span><span class="s">&quot;aw&quot;</span><span class="p">,</span><span class="err">@</span><span class="n">progbits</span>
</span><span class='line'>    <span class="p">.</span><span class="n">globl</span>  <span class="n">OBJC_CLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">align</span>  <span class="mi">8</span>
</span><span class='line'><span class="nl">OBJC_CLASS_$_MySuperClass:</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_METACLASS_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">OBJC_CLASS_$_Object</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_cache</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">_objc_empty_vtable</span>
</span><span class='line'>    <span class="p">.</span><span class="n">quad</span>   <span class="n">l_OBJC_CLASS_RO_$_MySuperClass</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span>   <span class="n">OBJC_CLASS_$_MySuperClass</span><span class="p">,</span> <span class="mi">40</span>
</span></code></pre></td></tr></table></div></figure>


<p>在编译得到的汇编代码中，不同的代码段对应ObjectiveC runtime中不同类型的数据结构。</p>

<p><code>main</code>函数通常是我们认为的程序的入口，但是实际上，在进程刚刚开始执行时，<code>_objc_init</code>函数会在<code>main</code>函数之前被调用，在<code>_objc_init</code>函数中我们看到如下语句</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dyld_register_image_state_change_handler</span><span class="p">(</span><span class="n">dyld_image_state_bound</span><span class="p">,</span>
</span><span class='line'>                                             <span class="mi">1</span><span class="cm">/*batch*/</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_images</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>即在<code>_objc_init</code>时，runtime调用了<code>map_images</code>方法，<code>map_images</code>中又调用了<code>map_images_nolock</code>方法，继续下去我们会发现，程序调用了名为<code>realizeAllClasses</code>的方法，并最终在<code>static Class realizeClass(Class cls)</code>中具体实现了对某一个类的加载。</p>

<p>在<code>static Class realizeClass(Class cls)</code>中，系统实现了对类<code>cls</code>的初始化，包括为类对象分配空间，生成类的函数列表等。在这里我们以Category的实现为例。</p>

<p>我们可以在<code>static void methodizeClass(Class cls)</code>方法中看到对<code>static void attachCategoryMethods</code>的调用，这个方法就是我们要找的category的实现原理所在：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">attachCategoryMethods</span><span class="p">(</span><span class="n">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">category_list</span> <span class="o">*</span><span class="n">cats</span><span class="p">,</span> <span class="n">bool</span> <span class="n">flushCaches</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cats</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">PrintReplacedMethods</span><span class="p">)</span> <span class="n">printReplacements</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">bool</span> <span class="n">isMeta</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">isMetaClass</span><span class="p">();</span>
</span><span class='line'>    <span class="n">method_list_t</span> <span class="o">**</span><span class="n">mlists</span> <span class="o">=</span> <span class="p">(</span><span class="n">method_list_t</span> <span class="o">**</span><span class="p">)</span>
</span><span class='line'>        <span class="n">_malloc_internal</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mlists</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Count backwards through cats to get newest categories first</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">fromBundle</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">mlist</span> <span class="o">=</span> <span class="n">cat_method_list</span><span class="p">(</span><span class="n">cats</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cat</span><span class="p">,</span> <span class="n">isMeta</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">mlists</span><span class="p">[</span><span class="n">mcount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>
</span><span class='line'>            <span class="n">fromBundle</span> <span class="o">|=</span> <span class="n">cats</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fromBundle</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">attachMethodLists</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">mlists</span><span class="p">,</span> <span class="n">mcount</span><span class="p">,</span> <span class="n">NO</span><span class="p">,</span> <span class="n">fromBundle</span><span class="p">,</span> <span class="n">flushCaches</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">_free_internal</span><span class="p">(</span><span class="n">mlists</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数第一个参数为当前正加载的类，第二个参数为对应类的所有的category的实现，在方法中，程序遍历了所有的category，将所有的在category中定义的函数，放在<code>mlists</code>中，然后利用<code>attachMethodLists</code>方法将category中添加的方法整合到类的method list当中，从而实现了category这一语言特性。</p>

<p>代码并不复杂，关键是我们在月的的过程中要慢慢找到函数间的调用层次，类加载这一部分的函数调用层次如下所示：
<img src="https://raw.githubusercontent.com/Charlesjean/cn/master/source/_posts/Category.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++11之Move 构造函数和Move 赋值操作符]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/13/c-plus-plus-11-move-semantic/"/>
    <updated>2014-04-13T11:19:04+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/13/c-plus-plus-11-move-semantic</id>
    <content type="html"><![CDATA[<p>Move语义是C++11中为了提高性能，减少临时对象的构造和析构而引入的新的语义环境，和Move语义相关的还有右值引用(rvalue reference)，这里我们总结一下，Move语义的引入带来了哪些好处，当我们定义一个类时需要注意什么。</p>

<h4>Move语义及移动构造函数</h4>

<p>我们通过代码来看一下Move语义出现的原因及必要性。</p>

<p>假设我们有如下的类定义，TestClass类中含有一个<code>Char*</code>类型的成员变量，为了实现内存的管理，按照<code>The Big Three</code>原则，我们需要为这个类定义<code>拷贝构造函数</code>，<code>析构函数</code>和<code>赋值操作符</code>。类的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">TestClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">_array</span><span class="p">)</span> <span class="o">:</span> <span class="n">array_pointer</span><span class="p">(</span><span class="n">_array</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Constructor Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">TestClass</span><span class="p">(){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Destructor is InVoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">delete</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="k">const</span> <span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Copy Constructor is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
</span><span class='line'>      <span class="n">memcpy</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">char</span><span class="o">*</span> <span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>拷贝构造函数</code>的语义为：当我们采用一个对象A去构造新的对象时，拷贝构造函数会被自动调用。拷贝构造函数的参数为<code>const TestClass&amp; rhs</code>决定了我们无法改变rhs的值。在下列情况下会使用拷贝构造函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">TestClass</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="n">TestClass</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于对象A的构造，拷贝构造函数完全符合我们的期望，因为我们使用了一个    <code>lvalue</code>来构造A，我们不希望改变<code>x</code>的内容，以便以后继续保持对<code>x</code>的引用。但是对于对象B的构造过程，拷贝构造函数明显做了多余的事情：</p>

<blockquote><p>  我们采用<code>rvalue</code>即一个临时变量来构造B，在B构造之后，临时变量会被销毁，我们不需要保持对这个临时变量的引用。因此，我们完全可以直接将构造函数中参数<code>rhs</code>的<code>array_pointer</code>指针直接给B，这样一来就可以省下B中<code>array_pointer</code>的初始化以及临时变量中<code>array_pointer</code>的释放过程。</p></blockquote>

<p>我们通过代码来进一步理解：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span><span class="c1">//directly assign pointer in rhs to the new object</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span><span class="c1">//do not let rhs refer to the raw pointer any more</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码就是我们所说的<code>Move Semantic</code>，当使用<code>rvalue</code>去构造或者给一个对象赋值时,我们可以直接将<code>rvalue</code>中的指针直接转移给新的对象，从而节省新的内存分配等的开销,由于<code>rvalue</code>在新的对象构造之后会被自动释放，所以我们没有必要保留对它的引用。</p>

<p>在C++11之前我们无法将上面的代码块写入构造函数中，因为我们无法区分<code>rhs</code>是不是<code>rvalue</code>。C++11中引入了右值引用，允许我们实现针对右值引用的函数重载（只在参数类型 指定右值即可），代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//This is move consturctor, transfer ownership</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//notice there are two &#39;&amp;&#39; symbols</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Move Construct is Invoked&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">;</span>
</span><span class='line'>      <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面就是移动构造函数（Move Constructor）,函数参数为<code>TestClass&amp;&amp;</code>，表明函数接受一个<code>rvalue</code>。</p>

<p>实现移动构造函数应注意两点:</p>

<ul>
<li>参数类型为TestClass&amp;&amp;</li>
<li>需要取消rhs中指针对原地址的引用（防止在rhs析构时导致原变量被释放）</li>
</ul>


<h4>移动赋值运算符</h4>

<p>了解了移动构造函数，很自然的想到在对对象进行赋值运算时同样存在<code>rvalue</code>的问题</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">A</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="n">B</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样我们可以重载移动赋值操作符如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="c1">//move assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(1)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">//assignment</span>
</span><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span><span class="c1">//(2)</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">TestClass</span> <span class="n">tmp</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">tmp</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们重载了两个<code>operator=</code>操作符，当我们对<code>A</code>赋值时,(2)会被调用，当我们对<code>B</code>赋值时，(1)会被调用。</p>

<p>在c++11中你可以采用上述做法，重载两个对应复制操作符的函数，也可以使用下面更简洁的方法(unifying assignment operator)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>  <span class="n">TestClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TestClass</span> <span class="n">rhs</span><span class="p">){</span>
</span><span class='line'>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Assign operator and Transfer ownership&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">array_pointer</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">array_pointer</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把函数的参数改成按值传递的形式（），这样做的好处有：
*   如果我们是以一个<code>lvalue</code>对对象进行赋值，那么系统会自动构建一个对象的拷贝作为函数的参数（因为是按值传递的）
*   如果我们是以一个<code>rvalue</code>对对象进行赋值，那么这个函数的表现会像（1）一样。</p>

<p>关于赋值操作符的重载可以参考<a href="http://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap">这篇文章</a>。</p>

<p>这里有一个<a href="https://github.com/Charlesjean/C11TestProjects">demo project</a>,有兴趣的话可以下来看一下代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之(三)NSObject类与NSObject接口]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/09/objectivec-runtime-learning-3/"/>
    <updated>2014-04-09T20:05:43+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/09/objectivec-runtime-learning-3</id>
    <content type="html"><![CDATA[<p>在学习ObjectiveC Runtime代码是你会发现，在系统中除了一个名为NSObject的类之外，还存在一个同样名字为NSObject的接口（Protocol），这不禁让我们有疑问，NSObject接口存在的原因是什么，同样的名字难道不会有冲突吗？</p>

<p>我们先看一下接口 NSObject的代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@protocol</span> <span class="nc">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">hash</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">superclass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nf">class</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">self</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="k">struct</span> <span class="n">_NSZone</span> <span class="o">*</span><span class="p">)</span><span class="nf">zone</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object1</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isProxy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isKindOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMemberOfClass:</span><span class="p">(</span><span class="n">Class</span><span class="p">)</span><span class="nv">aClass</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">conformsToProtocol:</span><span class="p">(</span><span class="n">Protocol</span> <span class="o">*</span><span class="p">)</span><span class="nv">aProtocol</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">respondsToSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">retain</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">oneway</span> <span class="kt">void</span><span class="p">)</span><span class="nf">release</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">retainCount</span> <span class="n">OBJC_ARC_UNAVAILABLE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">description</span><span class="p">;</span>
</span><span class='line'><span class="k">@optional</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">debugDescription</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们平时使用的runtime类型判断接口，以及<code>performSelector</code>等都定义在以NSObject为名的Protocol当中。这些方法在我们平时的编程过程中被大量使用，基本上所有的类都可以respond to这些方法，而我们的类都是继承自NSObject的，他们为什么会有NSObject Protocol当中声明的方法呢，唯一的解释就是<code>Class NSObject 实现了 NSObject Protocol</code>，在runtime的代码中我们也可以得到印证</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span>  <span class="n">OBJC_ISA_AVAILABILITY</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上在ObjectiveC中，interface和protocol的名字是可以相同的，因为在语言中不存在任何可以产生歧义的语法，也就是说interface和protocol使用于完全不同的语法环境，因此可以有相同的名字。</p>

<p>我们还可以进一步思考NSObject Protocol存在的必要性。在JAVA中，所有的类都是java.lang.Object的子类（Object是唯一的ROOT Class），而ObjectiveC中并不是所有的类都是NSObject的子类（有些类继承自NSProxy而不是NSObject）。因此在ObjectiveC中，为了给所有的类提供某些通用的接口，就必须保证所有的ROOT Class，都去实现某一个Protocol，NSObject Protocol就因此诞生，即<code>所有的root class，包括NSObject和NSProxy都会实现NSObject Protocol</code>， 我想这才是NSObject Protocol存在的根本原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之（二）安装Clang]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/04/03/objectivec-runtime-learning-2/"/>
    <updated>2014-04-03T21:20:48+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/04/03/objectivec-runtime-learning-2</id>
    <content type="html"><![CDATA[<p>在<a href="http://dj-chen.com/cn/blog/2014/03/26/objectivec-runtime-learning-1/">上一篇</a>中我们通过阅读代码，了解了ObjectiveC的内部对象模型的实现，接下来我们继续通过代码来了解ObjectiveC是如何加载一个类，以及ObjectiveC是如何实现对Category的支持的。</p>

<p>我们需要利用Clang来生成一部分中间代码，帮助我们了解runtime的运行机制，因此我们首先需要安装Clang。</p>

<p>Clang是LLVM的前端，可以用来编译C，C++，ObjectiveC等语言。传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。Clang则是以LLVM为后端的一款高效易用，并且与IDE结合很好的编译前端。</p>

<p>我们需要自己下载LLVM与Clang源代码进行编译，步骤如下：</p>

<figure class='code'><figcaption><span>lang=shell </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm 
</span><span class='line'>
</span><span class='line'>cd llvm/tools 
</span><span class='line'>svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
</span><span class='line'>cd ../..
</span><span class='line'>
</span><span class='line'>cd llvm/projects
</span><span class='line'>svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt
</span><span class='line'>cd ../..
</span><span class='line'>
</span><span class='line'>mkdir build 
</span><span class='line'>cd build
</span><span class='line'>../llvm/configure
</span><span class='line'>make</span></code></pre></td></tr></table></div></figure>


<p>至此，Clang 安装完毕，你可以使用<code>clang --help</code>来验证是否正确安装。</p>

<p>工欲善其事必先利其器，安装Clang主要是为我们今后的学习做准备，我本身对编译器没有特别深入的学习，如果你对Clang感兴趣可以<a href="http://clang.llvm.org/">参考这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android通过代码设置控件点击时颜色变化]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/03/30/android-statelistdrawable-and-colorstatelist/"/>
    <updated>2014-03-30T12:54:00+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/03/30/android-statelistdrawable-and-colorstatelist</id>
    <content type="html"><![CDATA[<p>在UI设计时，我们通常希望用户得到及时的交互反馈，例如在按钮上发生点击事件，或者textView上发生点击时，我们通常采用highlight一个控件的方法，提醒用户点击事件的发生。我们通常会通过改变控件的背景颜色或者字体的颜色来达到高亮的效果，Android提供了两个类，StateListDrawable和ColorStateList来支持这种操作。</p>

<p>在Android的<a href="http://developer.android.com/guide/topics/resources/color-list-resource.html">官方文档</a>以及网上很多资料中，我们可以看到这种高亮的支持都会通过编写xml来实现的。个人认为xml的实现方式虽然简单、可复用，但是如果我们有很多种状态，或者要动态的产生不同的颜色效果，那么XML的方式会使我们的工程中增加很多的resource文件，作为一个Programmer我更喜欢通过代码来达到相同的目的。本文所用的例子比较简单，仅仅是对一个textview做了高亮设置，当用户点击textiew时，会改变其背景色和字体颜色，可以在<a href="https://github.com/Charlesjean/FragmentTest">这里</a>下载代码。关键代码如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    *Add statedrawable for targetView to display different drawable when</span>
</span><span class='line'><span class="cm">    * view is in different state</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addStateDrawable</span><span class="o">(</span><span class="n">View</span> <span class="n">targetView</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">StateListDrawable</span> <span class="n">listDrawable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateListDrawable</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//add drawable used when view is pressed</span>
</span><span class='line'>        <span class="n">listDrawable</span><span class="o">.</span><span class="na">addState</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">android</span><span class="o">.</span><span class="na">R</span><span class="o">.</span><span class="na">attr</span><span class="o">.</span><span class="na">state_pressed</span><span class="o">},</span> <span class="k">new</span> <span class="n">ColorDrawable</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">rgb</span><span class="o">(</span><span class="mi">106</span><span class="o">,</span><span class="mi">170</span><span class="o">,</span><span class="mi">234</span><span class="o">)));</span>
</span><span class='line'>        <span class="c1">//show gray background for all other state</span>
</span><span class='line'>        <span class="n">listDrawable</span><span class="o">.</span><span class="na">addState</span><span class="o">(</span><span class="n">StateSet</span><span class="o">.</span><span class="na">WILD_CARD</span><span class="o">,</span> <span class="k">new</span> <span class="n">ColorDrawable</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">GRAY</span><span class="o">));</span>
</span><span class='line'>        <span class="n">targetView</span><span class="o">.</span><span class="na">setBackgroundDrawable</span><span class="o">(</span><span class="n">listDrawable</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * set different text color for different state</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addColorState</span><span class="o">(</span><span class="n">TextView</span> <span class="n">targetView</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">states</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">android</span><span class="o">.</span><span class="na">R</span><span class="o">.</span><span class="na">attr</span><span class="o">.</span><span class="na">state_pressed</span><span class="o">},</span>
</span><span class='line'>                <span class="n">StateSet</span><span class="o">.</span><span class="na">WILD_CARD</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">colors</span> <span class="o">=</span> <span class="o">{</span><span class="n">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">,</span> <span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">};</span>
</span><span class='line'>        <span class="n">ColorStateList</span> <span class="n">coloList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ColorStateList</span><span class="o">(</span><span class="n">states</span><span class="o">,</span> <span class="n">colors</span><span class="o">);</span>
</span><span class='line'>        <span class="n">targetView</span><span class="o">.</span><span class="na">setTextColor</span><span class="o">(</span><span class="n">coloList</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>StateListDrawable 提供了<code>addState</code>接口，使我们能够对应每一种状态，设置一个drawable；ColorStateList同样使我们为每一种状态指定一种字体颜色。 其中<code>StateSet.WILD_CARD</code>表示去除当前已有状态外的其他所有状态。</p>

<p>所谓状态就是指随着用户的交互，View所出的不同的状态。 其中<code>state_pressed</code>表示<code>when the user is pressing down in a view.</code>,更多对状态的描述可以参考<a href="http://developer.android.com/reference/android/graphics/drawable/StateListDrawable.html">android 文档</a> (个人认为android的很多文档写得很烂，完全是对字面意思的解释，这一点与iOS根本无法相比)。</p>

<h3>使用StateListDrawable和ColorStateList需要注意的事项</h3>

<ul>
<li>首先由于控件的状态是随着用户的点击等事件而改变的，所以要想使之前的代码能起作用，我们必须确保view能够接受用户的点击事件，最基本的必须用<code>setClickable(true)</code>,使控件可以点击</li>
<li>由于android对点击等事件的传递有一定的规则，要使<code>StateListDrawable</code>和<code>ColorStateList</code>起作用，最根本上要保证view的<strong>onTouchEvent</strong>函数能够被调用到，即TouchEvent不能被其他的对象 如<code>ParentView</code>和<code>TouchListener</code>所截断。(如果view注册了EventListener那么事件就会在传给onTouchEvent()函数之前，被EventListener截断)。</li>
</ul>


<p>关于Android中事件的传递机制，可以参考<a href="">这篇文章</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入ObjectiveC Runtime之对象模型]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/03/26/objectivec-runtime-learning-1/"/>
    <updated>2014-03-26T07:36:12+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/03/26/objectivec-runtime-learning-1</id>
    <content type="html"><![CDATA[<p>ObjectiveC与C++同样是在C的基础上对C的扩展，但与C++相比，我认为ObjectiveC提供了更加强大的功能，比如Category，forward message, method-swiazzing, KVO以及一些runtime接口，而所有这些技术都是以ObjectiveC强大的Runtime为基础的。因此只有深入学习了runtime的机制，才能使我们对OC的使用更加得心应手， 并且对于大多数runtime技术，我们必须在熟悉它的底层实现机制后才能够达到正确使用的目的，否则的话你将陷入痛苦的debug之中。</p>

<p>对象模型是程序运行时对象在内存中的组织方式，由于ObjectiveC是OOP的编程语言，对象模型就涉及到<code>类的组织方式</code>,<code>继承关系的表示方法</code>，<code>成员变量与函数的存储方式</code>，<code>如何实现RTTI</code>等，因此对象模型是我们了解ObjectiveC runtime技术实现机制的基础。</p>

<h3>ObjectiveC中对象的数据结构</h3>

<p>我们都知道，ObjectiveC中的大多数类都是NSObject的子类，因此我们先从NSObject的结构开始,在NSObject.h中我们可以看到如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NS_ROOT_CLASS</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSObject</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span>  <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>NSObject类中只有一个名为<code>isa</code>的<code>Class</code>类型的变量，跳转到<code>Class</code>的定义我们可以看到：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_class</span> <span class="o">*</span><span class="n">Class</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Class</code>为指向<code>objc_class</code>的指针，而<code>objc_class</code>就代表了在Objectivec中一个类的定义。其源代码定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_class</span> <span class="o">:</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Class ISA;</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">superclass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cache_t</span> <span class="n">cache</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们看到<code>objc_class</code>继承自<code>objc_object</code>,而<code>objc_object</code>的定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="n">uintptr_t</span> <span class="n">isa</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>objc_object只保存了一个<code>isa</code>指针，在原代码中我们还可以看到</p>

<pre><code>typedef struct objc_object *id;
</code></pre>

<p>看到这里一切应该都已经明了了。我们知道在ObjectiveC中每一个对象都是一个<code>id</code>,所以<code>objc_object</code>就是我们每一个对象在内存中的结构，它保存了一个指向<code>objc_class</code>的指针，这个指针就指向对象所对应的类在内存中的位置。</p>

<p>既然<code>objc_class</code>代表了ObjectiveC中的类，那么结构中必然需要存储类的相关信息，包括类的名字，成员函数的位置等信息，在ObjectiveC2.0中，这些信息被封装在了<code>class_rw_t</code>和<code>class_ro_t</code>当中，他们代码定义如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">class_rw_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">version</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">class_ro_t</span> <span class="o">*</span><span class="n">ro</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">**</span><span class="n">method_lists</span><span class="p">;</span>  <span class="c1">// RW_METHOD_ARRAY == 1</span>
</span><span class='line'>        <span class="n">method_list_t</span> <span class="o">*</span><span class="n">method_list</span><span class="p">;</span>    <span class="c1">// RW_METHOD_ARRAY == 0</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">chained_property_list</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">protocol_list_t</span> <span class="o">**</span> <span class="n">protocols</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Class</span> <span class="n">firstSubclass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">nextSiblingClass</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">class_ro_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">instanceStart</span><span class="p">;</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">instanceSize</span><span class="p">;</span>
</span><span class='line'><span class="cp">#ifdef __LP64__</span>
</span><span class='line'>    <span class="n">uint32_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">uint8_t</span> <span class="o">*</span> <span class="n">ivarLayout</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">method_list_t</span> <span class="o">*</span> <span class="n">baseMethods</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">protocol_list_t</span> <span class="o">*</span> <span class="n">baseProtocols</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">ivar_list_t</span> <span class="o">*</span> <span class="n">ivars</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="n">uint8_t</span> <span class="o">*</span> <span class="n">weakIvarLayout</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">property_list_t</span> <span class="o">*</span><span class="n">baseProperties</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此我们基本上了解了ObjectiveC中对象的组织形式，总结如下：</p>

<blockquote><p>每一个ObjectiveC对象都保存了一个<code>isa</code>指针指向其所对应的类的实现<code>objc_class</code>，而<code>objc_class</code>中保存了类父类，名称，函数列表，以及Protocol等信息。</p></blockquote>

<p>但是有些内容还不是特别清晰：</p>

<blockquote><ul>
<li>对象的成员变量应该是局部于对象的，不应该保存在<code>objc_class</code>中，对于成员变量这部分的实现还不清晰</li>
<li>对于大部分文章中提到的<code>元类</code>在代码中是如何体现的？ 目前我在代码中没有看到</li>
</ul>
</blockquote>

<p>以上ObjectiveC基本的对象模型，在这个对象模型的基础上ObjectiveC提供给了我们丰富的Runtime特性以及OO的支持，以后我们会进一步深入了解一些重要特性的实现。</p>

<p>我阅读的代码版本是Objc4-551，是官方开源的最新代码，如果文章中有错误或者有更详尽的看法请留言，共同学习进步。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Github托管的Octopress个人博客]]></title>
    <link href="http://Charlesjean.github.io//cn/blog/2014/03/25/personal-blog-with-github-and-octopress/"/>
    <updated>2014-03-25T07:33:30+08:00</updated>
    <id>http://Charlesjean.github.io//cn/blog/2014/03/25/personal-blog-with-github-and-octopress</id>
    <content type="html"><![CDATA[<p>   Github Pages 一直是自己喜爱的博客形式，之前托管了一个简单的英文博客，直接将博客的源代码放在username.github.io项目下，
代码管理简单，但是需要github在访问时将Jeklly转换为静态的网页，未免会带来网站性能的损失。Octopress 提供了更好的管理博客的方法，并集成了更多可以使用的插件和自动化的功能，这个中文博客就是基于Octopress，仍然托管在Github上，不过不是以个人网页的形式，而是以project pages的形式托管.</p>

<p>  在部署octopress的时候，会遇到不少问题，这里主要来记录一下，以备以后使用.</p>

<h4>fatal：remote origin already exists</h4>

<p>我的配置环境为reby 1.9.3， 在根据Octopress的<a href="http://octopress.org/docs/setup/">官方文档</a>安装主题之后，并在github上建立好新的repository之后，执行rake setup_github_pages会出错，提示</p>

<pre><code>remote origin already exists
</code></pre>

<p>解决方法：将Octopress/Rakefile中357行</p>

<pre><code>git remote add origin #{repo_url} 改为 git remote set-url origin #{repo_url}
</code></pre>

<h4>修改相应的配置文件</h4>

<p>由于现在的中文博客是放在github的一个project上，目的是为了实现如下方式访问：username.github.io/project,所以我们需要修改一下Octopress的配置文件，来指明目录结构。</p>

<ul>
<li>_config.yml:修改url,root,destination</li>
<li>config.rb:修改http_path,http_image_path,http_fonts_path,css_dir</li>
</ul>


<p>具体的改变可以参考<a href="https://github.com/Charlesjean/cn">这里</a>相对应的文件。</p>

<h4>UTF-8或者GB2312编码问题</h4>

<p>在执行rake generate命令之后，如果遇到 invalid byte sequence UTF-8 等错误，说明在你的文件当中有非法的编码字符，这些字符可能是由于我们使用的编辑器默认添加的一些字符，这里我们首先推荐使用nodepad++或者markdown专用的编辑器。</p>

<p>解决方法：</p>

<ul>
<li>修改Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-0.12.1\lib\jekyll\convertible.rb， 改变如下</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.content = File.read(File.join(base, name),:encoding=>"utf-8")</span></code></pre></td></tr></table></div></figure>


<ul>
<li>利用nodepad++找出非法字符，并将文档编码设置为utf-8 without BOM</li>
</ul>


<p>上面基本上列出了我在搭建过程中遇到的问题，喜欢用github搭建博客的都起码有一些编程能力，相信大家应该都可以很好地解决这些基本的问题，也欢迎大家反映自己遇到的问题，我们一起讨论解决。</p>

<p>再一次感谢Github提供了如此简单，可靠，关键还是免费的搭建博客的支持:)</p>
]]></content>
  </entry>
  
</feed>
